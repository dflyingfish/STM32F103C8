###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.1.11101/W32 for ARM       13/Sep/2018  23:24:36
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\STM32\IAR_projects\stm32f103_demo_new\Web\MCLibrary\src\ICS_HD2_PWMnCurrFdbkClass.c
#    Command line =  
#        D:\STM32\IAR_projects\stm32f103_demo_new\Web\MCLibrary\src\ICS_HD2_PWMnCurrFdbkClass.c
#        -D USE_STDPERIPH_DRIVER -D STM32F10X_MD -D MC_LIBRARY_SINGLE -lcN
#        "D:\STM32\IAR_projects\stm32f103_demo_new\Web\Project\EWARM\MC Library
#        Compiled\STM32F10x_SD\List" -o
#        "D:\STM32\IAR_projects\stm32f103_demo_new\Web\Project\EWARM\MC Library
#        Compiled\STM32F10x_SD\Obj" --debug --endian=little --cpu=Cortex-M3 -e
#        --fpu=None --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.4\arm\INC\c\DLib_Config_Normal.h" -I
#        D:\STM32\IAR_projects\stm32f103_demo_new\Web\Project\EWARM\..\ -I
#        D:\STM32\IAR_projects\stm32f103_demo_new\Web\Project\EWARM\..\..\MCLibrary\
#        -I
#        D:\STM32\IAR_projects\stm32f103_demo_new\Web\Project\EWARM\..\..\MCLibrary\inc\
#        -I
#        D:\STM32\IAR_projects\stm32f103_demo_new\Web\Project\EWARM\..\..\MCLibrary\interface\
#        -I
#        D:\STM32\IAR_projects\stm32f103_demo_new\Web\Project\EWARM\..\..\MCLibrary\interface\common\
#        -I
#        D:\STM32\IAR_projects\stm32f103_demo_new\Web\Project\EWARM\..\..\..\Common\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x\
#        -I
#        D:\STM32\IAR_projects\stm32f103_demo_new\Web\Project\EWARM\..\..\..\Common\Libraries\STM32F10x_StdPeriph_Driver\inc\
#        -Oh --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.4\arm\CMSIS\Include\"
#    Locale       =  C
#    List file    =  
#        D:\STM32\IAR_projects\stm32f103_demo_new\Web\Project\EWARM\MC Library
#        Compiled\STM32F10x_SD\List\ICS_HD2_PWMnCurrFdbkClass.lst
#    Object file  =  
#        D:\STM32\IAR_projects\stm32f103_demo_new\Web\Project\EWARM\MC Library
#        Compiled\STM32F10x_SD\Obj\ICS_HD2_PWMnCurrFdbkClass.o
#
###############################################################################

D:\STM32\IAR_projects\stm32f103_demo_new\Web\MCLibrary\src\ICS_HD2_PWMnCurrFdbkClass.c
      1          /**
      2            ******************************************************************************
      3            * @file    ICS_HD2_PWMnCurrFdbkClass.c
      4            * @author  STMicroelectronics - System Lab - MC Team
      5            * @version 4.3.0
      6            * @date    22-Sep-2016 15:29
      7            * @brief   This file contains private implementation of current sensor class in 
      8            *          case of dual motors and in case ICS and STM32F103 High Density is 
      9            *          used           
     10            ******************************************************************************
     11            * @attention
     12            *
     13            * <h2><center>&copy; COPYRIGHT 2016 STMicroelectronics</center></h2>
     14            *
     15            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     16            * You may not use this file except in compliance with the License.
     17            * You may obtain a copy of the License at:
     18            *
     19            *        http://www.st.com/software_license_agreement_liberty_v2
     20            *
     21            * Unless required by applicable law or agreed to in writing, software 
     22            * distributed under the License is distributed on an "AS IS" BASIS, 
     23            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     24            * See the License for the specific language governing permissions and
     25            * limitations under the License.
     26            *
     27            ******************************************************************************
     28            */
     29          
     30          #if (STM32F10X_HD)
     31          
     32          /* Includes ------------------------------------------------------------------*/
     33          #include "PWMnCurrFdbkClass.h"
     34          #include "PWMnCurrFdbkPrivate.h"
     35          #include "ICS_HD2_PWMnCurrFdbkClass.h"
     36          #include "ICS_HD2_PWMnCurrFdbkPrivate.h"
     37          #include "MCIRQHandlerClass.h"
     38          #include "MCIRQHandlerPrivate.h"
     39          #include "MCLibraryConf.h"
     40          #include "MCLibraryISRPriorityConf.h"
     41          #include "MC_type.h"
     42          
     43          /* ADC1 Data Register address */
     44          #define ADC1_DR_Address     0x4001244Cu
     45          
     46          /* ADC SMPx mask */
     47          #define SMPR1_SMP_Set              ((uint32_t) (0x00000007u))
     48          #define SMPR2_SMP_Set              ((uint32_t) (0x00000007u))
     49          /* Bit Banding */
     50          #define ADC1_CR2_EXTTRIG_SWSTART_BB             0x42248158u
     51          
     52          #define TIMxCCER_MASK              ((uint16_t)  ~0x1555u)
     53          #define TIMxCCER_MASK_CH123        ((uint16_t)  0x555u)
     54          
     55          #define TIMx_CC4E_BIT              ((uint16_t)  0x1000u) 
     56          
     57          #define CONV_STARTED               ((uint32_t) (0x8))
     58          #define CONV_FINISHED              ((uint32_t) (0xC))
     59          #define FLAGS_CLEARED              ((uint32_t) (0x0))
     60          #define ADC_SR_MASK                ((uint32_t) (0xC))
     61          
     62          #define ADC_RIGHT_ALIGNMENT 3u
     63          
     64          #define NB_CONVERSIONS 16u
     65          
     66          #define CLASS_VARS   ((_CPWMC)this)->Vars_str
     67          #define DCLASS_PARAMS ((_DCIHD2_PWMC)(((_CPWMC) this)->DerivedClass))->pDParams_str
     68          #define DCLASS_VARS  ((_DCIHD2_PWMC)(((_CPWMC) this)->DerivedClass))->DVars_str
     69          
     70          #ifdef MC_CLASS_DYNAMIC
     71          #include "stdlib.h" /* Used for dynamic allocation */
     72          #else
     73          _DCIHD2_PWMC_t IHD2_PWMCpool[MAX_DRV_PWMC_NUM];
     74          unsigned char IHD2_PWMC_Allocated = 0u;
     75          #endif
     76          
     77          /*#define DEBUG*/
     78          
     79          #ifdef DEBUG
     80          static volatile _CPWMC oPWMCdbg;
     81          static volatile _DCIHD2_PWMC oIHD2dbg;
     82          #endif
     83          
     84          static void IHD2_Init(CPWMC this);
     85          static void IHD2_TIMxInit(TIM_TypeDef* TIMx, CPWMC this);
     86          static void IHD2_CurrentReadingCalibration(CPWMC this);
     87          static void IHD2_GetPhaseCurrents(CPWMC this,Curr_Components* pStator_Currents);
     88          static void IHD2_TurnOnLowSides(CPWMC this);
     89          static void IHD2_SwitchOnPWM(CPWMC this);
     90          static void IHD2_SwitchOffPWM(CPWMC this);
     91          static uint16_t IHD2_WriteTIMRegisters(CPWMC this);   
     92          static void *IHD2_IRQHandler(void *this, unsigned char flag);
     93          static uint16_t IHD2_ExecRegularConv(CPWMC this, uint8_t bChannel);
     94          static void IHD2_ADC_SetSamplingTime(CPWMC this, ADConv_t ADConv_struct);
     95          static void IHD2_HFCurrentsCalibration(CPWMC this,Curr_Components* pStator_Currents);
     96          static uint16_t IHD2_IsOverCurrentOccurred(CPWMC this);
     97          
     98          /**
     99          * @brief  Creates an object of the class ICS_HD2
    100          * @param  pPWMnCurrFdbkParams pointer to an PWMnCurrFdbk parameters structure
    101          * @param  pICS_DDParams pointer to an ICS_DD parameters structure
    102          * @retval CIHD2_PWMC new instance of ICS_HD2 object
    103          */
    104          CIHD2_PWMC IHD2_NewObject(pPWMnCurrFdbkParams_t pPWMnCurrFdbkParams, 
    105                                              pICS_DDParams_t pICS_DDParams)
    106          {
    107            _CPWMC _oPWMnCurrFdbk;
    108            _DCIHD2_PWMC _oICS_HD2;
    109            
    110            _oPWMnCurrFdbk = (_CPWMC)PWMC_NewObject(pPWMnCurrFdbkParams);
    111            
    112          #ifdef MC_CLASS_DYNAMIC
    113            _oICS_HD2 = (_DCIHD2_PWMC)calloc(1u,sizeof(_DCIHD2_PWMC_t));
    114          #else
    115            if (IHD2_PWMC_Allocated  < MAX_DRV_PWMC_NUM)
    116            {
    117              _oICS_HD2 = &IHD2_PWMCpool[IHD2_PWMC_Allocated++];
    118            }
    119            else
    120            {
    121              _oICS_HD2 = MC_NULL;
    122            }
    123          #endif
    124            
    125            _oICS_HD2->pDParams_str = pICS_DDParams;
    126            _oPWMnCurrFdbk->DerivedClass = (void*)_oICS_HD2;
    127            
    128            _oPWMnCurrFdbk->Methods_str.pIRQ_Handler = &IHD2_IRQHandler;
    129            
    130            Set_IRQ_Handler(pICS_DDParams->IRQnb, (_CMCIRQ)_oPWMnCurrFdbk);
    131            
    132            _oPWMnCurrFdbk->Methods_str.pPWMC_Init = &IHD2_Init;
    133            _oPWMnCurrFdbk->Methods_str.pPWMC_GetPhaseCurrents = &IHD2_GetPhaseCurrents;
    134            _oPWMnCurrFdbk->Methods_str.pPWMC_SwitchOffPWM = &IHD2_SwitchOffPWM;
    135            _oPWMnCurrFdbk->Methods_str.pPWMC_SwitchOnPWM = &IHD2_SwitchOnPWM;        
    136            _oPWMnCurrFdbk->Methods_str.pPWMC_CurrentReadingCalibr = 
    137                                                           &IHD2_CurrentReadingCalibration;         
    138            _oPWMnCurrFdbk->Methods_str.pPWMC_TurnOnLowSides = &IHD2_TurnOnLowSides;         
    139            _oPWMnCurrFdbk->Methods_str.pPWMC_SetADCSampPointSect1 = 
    140                                                                &IHD2_WriteTIMRegisters;        
    141            _oPWMnCurrFdbk->Methods_str.pPWMC_SetADCSampPointSect2 = 
    142                                                                &IHD2_WriteTIMRegisters; 
    143            _oPWMnCurrFdbk->Methods_str.pPWMC_SetADCSampPointSect3 = 
    144                                                                &IHD2_WriteTIMRegisters;        
    145            _oPWMnCurrFdbk->Methods_str.pPWMC_SetADCSampPointSect4 = 
    146                                                                &IHD2_WriteTIMRegisters;         
    147            _oPWMnCurrFdbk->Methods_str.pPWMC_SetADCSampPointSect5 = 
    148                                                                &IHD2_WriteTIMRegisters;        
    149            _oPWMnCurrFdbk->Methods_str.pPWMC_SetADCSampPointSect6 = 
    150                                                                &IHD2_WriteTIMRegisters; 
    151            _oPWMnCurrFdbk->Methods_str.pPWMC_ExecRegularConv= &IHD2_ExecRegularConv;
    152            
    153            _oPWMnCurrFdbk->Methods_str.pPWMC_SetSamplingTime= &IHD2_ADC_SetSamplingTime;
    154            
    155            _oPWMnCurrFdbk->Methods_str.pPWMC_IsOverCurrentOccurred = 
    156              &IHD2_IsOverCurrentOccurred;
    157            
    158            return ((CIHD2_PWMC)_oPWMnCurrFdbk);
    159          }
    160          
    161          /** @addtogroup STM32F10x_PMSM_MC_Library
    162          * @{
    163          */
    164          
    165          /** @addtogroup PWMnCurrFdbk_ICS_HD2
    166          * @{
    167          */
    168          
    169          /** @defgroup ICS_HD2_class_private_methods ICS_HD2 class private methods
    170          * @{
    171          */
    172          
    173          /**
    174          * @brief  It initializes TIMx, ADC, GPIO, DMA1 and NVIC for current reading 
    175          *         in ICS configuration using STM32F103x High Density
    176          * @param  this: related object of class CIHD2_PWMC
    177          * @retval none
    178          */
    179          static void IHD2_Init(CPWMC this)
    180          {
    181            DMA_InitTypeDef DMA_InitStructure;
    182            NVIC_InitTypeDef NVIC_InitStructure;
    183            GPIO_InitTypeDef GPIO_InitStructure;
    184            ADC_InitTypeDef ADC_InitStructure;
    185            uint16_t hAux;
    186            pVars_t pVars_str = &CLASS_VARS;
    187            pDVars_t pDVars_str = &DCLASS_VARS;  
    188            pDParams_t pDParams_str = DCLASS_PARAMS; 
    189            uint32_t wAux1, wAux2, wAux3, wAux4;
    190            
    191            pDVars_str->Half_PWMPeriod = ((((_CPWMC) this)->pParams_str->hPWMperiod)/2u);
    192            pVars_str->bMotor = (pDParams_str->bInstanceNbr==1u?M1:M2);
    193              
    194            /* Peripheral clocks enabling ---------------------------------------------*/
    195            
    196            RCC->AHBENR |= RCC_AHBPeriph_CRC;
    197            
    198            /* ADCCLK = PCLK2 */
    199            RCC_ADCCLKConfig(pDParams_str ->wADC_Clock_Divider);
    200            /* Enable ADC1 clock */
    201            RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);
    202            /* Enable ADC2 clock */
    203            RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC2, ENABLE); 
    204            /* Enable GPIOA-GPIOF clock */
    205            RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO | RCC_APB2Periph_GPIOA | 
    206                                   RCC_APB2Periph_GPIOB | RCC_APB2Periph_GPIOC | 
    207                                     RCC_APB2Periph_GPIOD | RCC_APB2Periph_GPIOE | 
    208                                       RCC_APB2Periph_GPIOF | RCC_APB2Periph_GPIOG, ENABLE);  
    209            
    210            /* Enable the CCS */
    211            RCC_ClockSecuritySystemCmd((FunctionalState)(ENABLE));
    212            
    213             /* Enable DMA1 clock */
    214            RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE); 
    215            
    216            if(pDParams_str->TIMx == TIM1)
    217            {
    218              /* Enable TIM1 clock */
    219              RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM1, ENABLE);
    220            }
    221            else
    222            {
    223              /* Enable TIM8 clock */
    224              RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM8, ENABLE);
    225            }
    226          	
    227          	IHD2_TIMxInit(pDParams_str->TIMx, this);
    228            
    229            /* GPIOs configurations --------------------------------------------------*/
    230            GPIO_StructInit(&GPIO_InitStructure);
    231            
    232            /****** Configure phase A ADC channel GPIO as analog input ****/
    233            GPIO_InitStructure.GPIO_Pin = pDParams_str->hIaPin;  
    234            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
    235            GPIO_Init(pDParams_str->hIaPort,
    236                      &GPIO_InitStructure);
    237            GPIO_PinLockConfig(pDParams_str->hIaPort, pDParams_str->hIaPin);
    238            
    239            /****** Configure phase B ADC channel GPIO as analog input ****/
    240            GPIO_InitStructure.GPIO_Pin = pDParams_str->hIbPin;  
    241            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
    242            GPIO_Init(pDParams_str->hIbPort, &GPIO_InitStructure);
    243            GPIO_PinLockConfig(pDParams_str->hIbPort, pDParams_str->hIbPin);
    244            
    245            /* Alternate function remapping available only for TIM1 */
    246            if(pDParams_str->TIMx == TIM1)
    247            {     
    248              /****** Timer1 alternate function full remapping ******/  
    249              if((pDParams_str-> wTIM1Remapping) != GPIO_NoRemap_TIM1)
    250              {   
    251                GPIO_PinRemapConfig(pDParams_str->wTIM1Remapping, ENABLE);  
    252              }  
    253            }
    254            
    255            /****** Configure TIMx Channel 1, 2 and 3 Outputs ******/ 
    256            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
    257            GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    258            
    259            hAux = (pDParams_str->hCh1Pin) | (pDParams_str->hCh2Pin);  
    260            hAux = hAux | (pDParams_str->hCh3Pin);  
    261            GPIO_InitStructure.GPIO_Pin = hAux; 
    262            GPIO_Init(pDParams_str->hCh1Port, &GPIO_InitStructure);
    263            GPIO_PinLockConfig(pDParams_str->hCh1Port, hAux);
    264            
    265            /****** Configure TIMx Channel 1N, 2N and 3N Outputs, if enabled ******/    
    266            if ((pDParams_str->LowSideOutputs)== LS_PWM_TIMER)
    267            { 
    268              GPIO_InitStructure.GPIO_Pin = pDParams_str->hCh1NPin;  
    269              GPIO_Init(pDParams_str->hCh1NPort, &GPIO_InitStructure);  
    270              GPIO_PinLockConfig(pDParams_str->hCh1NPort, pDParams_str->hCh1NPin);
    271              
    272              hAux = (pDParams_str->hCh2NPin) | (pDParams_str->hCh3NPin);
    273              GPIO_InitStructure.GPIO_Pin = hAux; 
    274              GPIO_Init(pDParams_str->hCh2NPort, &GPIO_InitStructure);
    275              GPIO_PinLockConfig(pDParams_str->hCh2NPort, hAux);    
    276            }  else if ((pDParams_str->LowSideOutputs)== ES_GPIO)
    277            {
    278              /* Only "active high" polarity is supported */
    279              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
    280              GPIO_InitStructure.GPIO_Pin = pDParams_str->hCh1NPin;  
    281              GPIO_Init(pDParams_str->hCh1NPort, &GPIO_InitStructure);  
    282              GPIO_PinLockConfig(pDParams_str->hCh1NPort, pDParams_str->hCh1NPin);
    283              
    284              hAux = (pDParams_str->hCh2NPin) | (pDParams_str->hCh3NPin);
    285              GPIO_InitStructure.GPIO_Pin = hAux; 
    286              GPIO_Init(pDParams_str->hCh2NPort, &GPIO_InitStructure);    
    287              GPIO_PinLockConfig(pDParams_str->hCh2NPort, hAux);
    288            }
    289            else
    290            {
    291            }
    292            
    293            if ((pDParams_str->EmergencyStop)!= DISABLE)  
    294            {
    295              /****** Configure TIMx BKIN input, if enabled ******/   
    296              GPIO_StructInit(&GPIO_InitStructure);
    297              GPIO_InitStructure.GPIO_Pin = pDParams_str->hBKINPin;  
    298              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    299              GPIO_Init(pDParams_str->hBKINPort, &GPIO_InitStructure); 
    300              GPIO_PinLockConfig(pDParams_str->hBKINPort, pDParams_str->hBKINPin);
    301            }
    302            
    303            if(pDParams_str->TIMx == TIM1)
    304            {   
    305              /* TIM1 Counter Clock stopped when the core is halted */
    306              DBGMCU_Config(DBGMCU_TIM1_STOP, ENABLE);
    307            }
    308            else
    309            {
    310              /* TIM8 Counter Clock stopped when the core is halted */
    311              DBGMCU_Config(DBGMCU_TIM8_STOP, ENABLE);
    312            }
    313            
    314            /* It saves the sampling time settings before DeInit in case of second instance */  
    315            wAux1 = ADC1->SMPR1;
    316            wAux2 = ADC1->SMPR2;
    317            wAux3 = ADC2->SMPR1;
    318            wAux4 = ADC2->SMPR2;
    319            
    320            /* ADC1 and ADC2 registers configuration ---------------------------------*/
    321            /* ADC1 and ADC2 registers reset */  
    322            ADC_DeInit(ADC1);
    323            ADC_DeInit(ADC2);
    324          
    325            /* ADC1 and ADC2 registers configuration ---------------------------------*/
    326            /* Enable ADC1 and ADC2 */
    327            ADC_Cmd(ADC1, ENABLE);
    328            ADC_Cmd(ADC2, ENABLE);
    329          
    330            
    331            ADC1->SMPR1 = wAux1;
    332            ADC1->SMPR2 = wAux2;  
    333            ADC2->SMPR1 = wAux3;
    334            ADC2->SMPR2 = wAux4;
    335            
    336            /* ADC Init */
    337            ADC_StructInit(&ADC_InitStructure);
    338            ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;
    339            ADC_InitStructure.ADC_ScanConvMode = DISABLE;
    340            ADC_InitStructure.ADC_ContinuousConvMode = DISABLE;
    341            ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;
    342            ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Left;
    343            ADC_InitStructure.ADC_NbrOfChannel = 1u;
    344            ADC_Init(ADC1, &ADC_InitStructure);
    345            ADC_Init(ADC2, &ADC_InitStructure);
    346            
    347            ADC_InjectedDiscModeCmd(ADC1, ENABLE);
    348            ADC_InjectedDiscModeCmd(ADC2, ENABLE);
    349          
    350            /* Enable external trigger (it will be SW) for ADC1 and ADC2 regular 
    351            conversions */ 
    352            ADC_ExternalTrigConvCmd(ADC1, ENABLE);
    353            ADC_ExternalTrigConvCmd(ADC2, ENABLE);
    354            
    355            /* Remap of Eternal trigger of ADC1 and 2 into TIM8 CH4 */
    356            GPIO_PinRemapConfig(GPIO_Remap_ADC1_ETRGINJ, ENABLE);
    357            GPIO_PinRemapConfig(GPIO_Remap_ADC2_ETRGINJ, ENABLE);
    358              
    359            /* Start calibration of ADC1 and ADC2 */
    360            ADC_StartCalibration(ADC1);
    361            ADC_StartCalibration(ADC2);
    362            
    363            /* Wait for the end of ADCs calibration */
    364            while (ADC_GetCalibrationStatus(ADC1) & ADC_GetCalibrationStatus(ADC2))
    365            {
    366            }
    367            
    368          /* It is used only to configure the sampling time to the corresponding channel*/
    369            ADC_InjectedChannelConfig(ADC1, pDParams_str->bIaChannel, 1u,
    370                                                          pDParams_str->b_IaSamplingTime);
    371            ADC_InjectedChannelConfig(ADC2, pDParams_str->bIbChannel, 1u,
    372                                                          pDParams_str->b_IbSamplingTime);    
    373            
    374            /* DMA Event related to ADC regular conversion*/
    375            /* DMA1 channel1 configuration */
    376            DMA_DeInit(DMA1_Channel1);
    377            DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t)ADC1_DR_Address;
    378            DMA_InitStructure.DMA_MemoryBaseAddr = (uint32_t)(&(pDVars_str->hRegConv));
    379            DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;
    380            DMA_InitStructure.DMA_BufferSize = 1u;
    381            DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
    382            DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Disable;
    383            DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;
    384            DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;
    385            DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;
    386            DMA_InitStructure.DMA_Priority = DMA_Priority_Low;
    387            DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;
    388            DMA_Init(DMA1_Channel1, &DMA_InitStructure);
    389            /* Enable DMA1 Channel1 */
    390            DMA_Cmd(DMA1_Channel1, ENABLE);
    391            /* Enable ADC1 EOC DMA */
    392            ADC_DMACmd(ADC1,ENABLE);  
    393          
    394            /* ADC1 Injected conversions end interrupt enabling */
    395            ADC_ClearFlag(ADC1, ADC_FLAG_JEOC); 	 
    396            ADC_ITConfig(ADC1, ADC_IT_JEOC, ENABLE); 
    397            
    398            /* Enable the ADC Interrupt */
    399            NVIC_InitStructure.NVIC_IRQChannel = (uint8_t) ADC1_2_IRQn;
    400            NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 
    401              ADC_PRE_EMPTION_PRIORITY;
    402            NVIC_InitStructure.NVIC_IRQChannelSubPriority = ADC_SUB_PRIORITY;
    403            NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    404            NVIC_Init(&NVIC_InitStructure);
    405            
    406            if(pDParams_str->TIMx==TIM1)
    407            {
    408              /* Enable the TIM1 Update interrupt */
    409              NVIC_InitStructure.NVIC_IRQChannel = (uint8_t) TIM1_UP_IRQn;
    410              NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = TIMx_UP_PRE_EMPTION_PRIORITY;
    411              NVIC_InitStructure.NVIC_IRQChannelSubPriority = TIMx_UP_SUB_PRIORITY;
    412              NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    413              NVIC_Init(&NVIC_InitStructure);   
    414            }
    415            else
    416            {
    417              /* Enable the TIM1 Update interrupt */
    418              NVIC_InitStructure.NVIC_IRQChannel = (uint8_t) TIM8_UP_IRQn;
    419              NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = TIMx_UP_PRE_EMPTION_PRIORITY;
    420              NVIC_InitStructure.NVIC_IRQChannelSubPriority = TIMx_UP_SUB_PRIORITY;
    421              NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    422              NVIC_Init(&NVIC_InitStructure);     
    423            }
    424          }
    425          
    426          /**
    427          * @brief  It initializes TIMx peripheral for PWM generation
    428          * @param 'TIMx': Timer to be initialized
    429          * @param 'this': related object of class CIHD2_PWMC
    430          * @retval none
    431          */
    432          static void IHD2_TIMxInit(TIM_TypeDef* TIMx, CPWMC this)
    433          {
    434            TIM_TimeBaseInitTypeDef TIMx_TimeBaseStructure;
    435            TIM_OCInitTypeDef TIMx_OCInitStructure;
    436            TIM_BDTRInitTypeDef TIMx_BDTRInitStructure;
    437            pDVars_t pDVars_str = &DCLASS_VARS;  
    438            pDParams_t pDParams_str =DCLASS_PARAMS; 
    439            
    440            /* TIMx Peripheral Configuration -------------------------------------------*/
    441            /* TIMx Registers reset */
    442            TIM_DeInit(TIMx);
    443            TIM_TimeBaseStructInit(&TIMx_TimeBaseStructure);
    444            /* Time Base configuration */
    445            TIMx_TimeBaseStructure.TIM_Prescaler = (uint16_t)(pDParams_str->bTim_Clock_Divider) - 1u;
    446            TIMx_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_CenterAligned1;
    447            TIMx_TimeBaseStructure.TIM_Period = pDVars_str->Half_PWMPeriod;
    448            TIMx_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV2;
    449            TIMx_TimeBaseStructure.TIM_RepetitionCounter = pDParams_str->
    450                                                                      bRepetitionCounter;
    451            TIM_TimeBaseInit(TIMx, &TIMx_TimeBaseStructure);
    452            
    453            /* Channel 1, 2,3 and 4 Configuration in PWM mode */
    454            TIM_OCStructInit(&TIMx_OCInitStructure);  
    455            TIMx_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1; 
    456            TIMx_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable; 
    457            TIMx_OCInitStructure.TIM_Pulse = pDVars_str->Half_PWMPeriod/2u; /* dummy value */
    458            
    459            /* Channel 1 */
    460            TIMx_OCInitStructure.TIM_OCPolarity = pDParams_str->hCh1Polarity;      
    461            TIMx_OCInitStructure.TIM_OCIdleState = pDParams_str->hCh1IdleState;    
    462            if ((pDParams_str->LowSideOutputs)== LS_PWM_TIMER) 
    463            {
    464              TIMx_OCInitStructure.TIM_OutputNState = TIM_OutputNState_Enable; 
    465              TIMx_OCInitStructure.TIM_OCNPolarity = pDParams_str->hCh1NPolarity; 
    466              TIMx_OCInitStructure.TIM_OCNIdleState = pDParams_str->hCh1NIdleState;     
    467            }    
    468            else
    469            {
    470              TIMx_OCInitStructure.TIM_OutputNState = TIM_OutputNState_Disable;
    471            }    
    472            TIM_OC1Init(TIMx, &TIMx_OCInitStructure); 
    473            
    474            
    475            /* Channel 2 */
    476            TIMx_OCInitStructure.TIM_OCPolarity = pDParams_str->hCh2Polarity;      
    477            TIMx_OCInitStructure.TIM_OCIdleState = pDParams_str->hCh2IdleState;    
    478            if ((pDParams_str->LowSideOutputs)== LS_PWM_TIMER)
    479            {
    480            TIMx_OCInitStructure.TIM_OCNPolarity = pDParams_str->hCh2NPolarity; 
    481            TIMx_OCInitStructure.TIM_OCNIdleState = pDParams_str->hCh2NIdleState;         
    482            }
    483            TIM_OC2Init(TIMx, &TIMx_OCInitStructure); 
    484            
    485            
    486            /* Channel 3 */
    487            TIMx_OCInitStructure.TIM_OCPolarity = pDParams_str->hCh3Polarity;      
    488            TIMx_OCInitStructure.TIM_OCIdleState = pDParams_str->hCh3IdleState;    
    489            if ((pDParams_str->LowSideOutputs)== LS_PWM_TIMER)
    490            {
    491            TIMx_OCInitStructure.TIM_OCNPolarity = pDParams_str->hCh3NPolarity; 
    492            TIMx_OCInitStructure.TIM_OCNIdleState = pDParams_str->hCh3NIdleState;         
    493            }
    494            TIM_OC3Init(TIMx, &TIMx_OCInitStructure);   
    495            
    496              /* Channel 4 */
    497            TIMx_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM2;
    498            TIMx_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;      
    499            TIMx_OCInitStructure.TIM_OCIdleState = TIM_OCIdleState_Reset; 
    500            TIMx_OCInitStructure.TIM_Pulse = DCLASS_VARS.Half_PWMPeriod+1u;
    501            TIM_OC4Init(TIMx, &TIMx_OCInitStructure); 
    502            
    503            /* Enables the TIMx Preload on CC1 Register */
    504            TIM_OC1PreloadConfig(TIMx, TIM_OCPreload_Enable);
    505            /* Enables the TIMx Preload on CC2 Register */
    506            TIM_OC2PreloadConfig(TIMx, TIM_OCPreload_Enable);
    507            /* Enables the TIMx Preload on CC3 Register */
    508            TIM_OC3PreloadConfig(TIMx, TIM_OCPreload_Enable);
    509            /* Enables the TIMx Preload on CC4 Register */
    510            TIM_OC4PreloadConfig(TIMx, TIM_OCPreload_Enable); 
    511            
    512            TIM_BDTRStructInit(&TIMx_BDTRInitStructure);
    513            /* Dead Time */
    514            TIMx_BDTRInitStructure.TIM_OSSRState = TIM_OSSRState_Enable;
    515            TIMx_BDTRInitStructure.TIM_OSSIState = TIM_OSSIState_Enable;
    516            TIMx_BDTRInitStructure.TIM_LOCKLevel = TIM_LOCKLevel_1; 
    517            TIMx_BDTRInitStructure.TIM_DeadTime = (pDParams_str->hDeadTime)/2u;
    518            /* BKIN, if enabled */
    519            if ((pDParams_str->EmergencyStop)!= DISABLE)  
    520            {
    521              TIMx_BDTRInitStructure.TIM_Break = TIM_Break_Enable;
    522              TIMx_BDTRInitStructure.TIM_BreakPolarity = pDParams_str->hBKINPolarity;
    523              TIMx_BDTRInitStructure.TIM_AutomaticOutput = TIM_AutomaticOutput_Disable;
    524              TIM_ClearITPendingBit(TIMx, TIM_IT_Break);
    525              TIM_ITConfig(TIMx, TIM_IT_Break, ENABLE);
    526            }  
    527            TIM_BDTRConfig(TIMx, &TIMx_BDTRInitStructure);
    528           
    529            TIM_SelectInputTrigger(TIMx,TIM_TS_ITR1);
    530            TIM_SelectSlaveMode(TIMx,TIM_SlaveMode_Trigger);
    531          
    532            /* Prepare timer for synchronization */
    533            TIM_GenerateEvent(TIMx,TIM_EventSource_Update);
    534                
    535            if (pDParams_str->bFreqRatio == 2u) 
    536            {
    537              if (pDParams_str->bIsHigherFreqTim == HIGHER_FREQ)
    538              {
    539                if (pDParams_str->bRepetitionCounter == 3u)
    540                {
    541                  /* Set TIMx repetition counter to 1 */
    542                  TIMx->RCR =0x01u; 
    543                  TIM_GenerateEvent(TIMx, TIM_EventSource_Update);
    544                  /* Repetition counter will be set to 3 at next Update */
    545                  TIMx->RCR =0x03u; 
    546                }
    547              }
    548              
    549              TIM_SetCounter(TIMx, pDVars_str->Half_PWMPeriod-1u);     
    550            }
    551            else /* bFreqRatio equal to 1 or 3 */
    552            {
    553              if (pDParams_str->bInstanceNbr == 1u)
    554              {
    555                TIM_SetCounter(TIMx, pDVars_str->Half_PWMPeriod-1u);
    556              }
    557            }
    558          }
    559          
    560          /**
    561          * @brief  It perform the start of all the timers required by the control. 
    562                    It utilizes TIM2 as temporary timer to achieve synchronization between 
    563                    PWM signals.
    564                    When this function is called, TIM1 and/or TIM8 must be in frozen state
    565                    with CNT, ARR, REP RATE and trigger correctly set (these setting are 
    566                    usually performed in the Init method accordingly with the configuration)
    567          * @param  none
    568          * @retval none
    569          */
    570           void IHD2_StartTimers(void)
    571          {
    572           TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;   
    573            
    574            /* Temporary Enable TIM2 clock */
    575            RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);
    576            TIM_DeInit(TIM2);
    577            TIM_TimeBaseStructInit(&TIM_TimeBaseStructure);
    578            /* Time Base configuration */
    579            TIM_TimeBaseStructure.TIM_Prescaler = 0x0u;
    580            TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
    581            TIM_TimeBaseStructure.TIM_Period = 1u; /* dummy */ 
    582            TIM_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV1;
    583            TIM_TimeBaseInit(TIM2, &TIM_TimeBaseStructure);
    584            
    585            TIM_SelectOutputTrigger(TIM2, TIM_TRGOSource_Update);  
    586               
    587            TIM_Cmd(TIM2, ENABLE);
    588            
    589            TIM_DeInit(TIM2);
    590            RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, DISABLE); 
    591          }
    592          
    593          
    594          /**
    595          * @brief  It stores into 'this' object variables the voltage present on Ia and 
    596          *         Ib current feedback analog channels when no current is flowin into the
    597          *         motor
    598          * @param  this: related object of class CIHD2_PWMC
    599          * @retval none
    600          */
    601          static void IHD2_CurrentReadingCalibration(CPWMC this)
    602          {
    603            pDVars_t pDVars_str = &DCLASS_VARS; 
    604            TIM_TypeDef*  LocalTIMx = DCLASS_PARAMS->TIMx;    
    605            uint16_t htempCCER, haux;
    606            
    607            pDVars_str-> wPhaseAOffset = 0u;
    608            pDVars_str-> wPhaseBOffset = 0u; 
    609            
    610            pDVars_str->bIndex=0u;
    611            
    612            /* Force inactive level on TIMx CHy and TIMx CHyN */ 
    613            htempCCER =  DCLASS_PARAMS->TIMx->CCER;
    614            haux = htempCCER & TIMxCCER_MASK;
    615            haux |= TIMx_CC4E_BIT;
    616            LocalTIMx->CCER = haux;
    617            
    618            /* Change function to be executed in ADCx_ISR */ 
    619            ((_CPWMC) this)->Methods_str.pPWMC_GetPhaseCurrents = &IHD2_HFCurrentsCalibration;
    620            
    621            IHD2_SwitchOnPWM(this);
    622            
    623            /* Wait for NB_CONVERSIONS to be executed */
    624            while (pDVars_str->bIndex < (NB_CONVERSIONS))
    625            {
    626              if (LocalTIMx->DIER & TIM_IT_Update)
    627              {}
    628              else
    629              {
    630                pDVars_str->bIndex = NB_CONVERSIONS;
    631              }
    632            }  
    633            
    634            IHD2_SwitchOffPWM( this);
    635            
    636            pDVars_str->wPhaseAOffset >>=3; 
    637            pDVars_str->wPhaseBOffset >>=3; 
    638           
    639            /* It over write TIMx CCRy wrongly written by FOC during calibration so as to 
    640             force 50% duty cycle on the three inverer legs */
    641            /* Disable TIMx preload */ 
    642            LocalTIMx->CCMR1 &= 0xF7F7u;
    643            LocalTIMx->CCMR2 &= 0xF7F7u;
    644            LocalTIMx->CCR1 = pDVars_str->Half_PWMPeriod;
    645            LocalTIMx->CCR2 = pDVars_str->Half_PWMPeriod;
    646            LocalTIMx->CCR3 = pDVars_str->Half_PWMPeriod;
    647            
    648            /* Enable TIMx preload */
    649            LocalTIMx->CCMR1 |= 0x0808u;
    650            LocalTIMx->CCMR2 |= 0x0808u;
    651            
    652            /* Set back TIMx CCER register */ 
    653            LocalTIMx->CCER = htempCCER;
    654          
    655            /* Change back function to be executed in ADCx_ISR */ 
    656            ((_CPWMC) this)->Methods_str.pPWMC_GetPhaseCurrents = &IHD2_GetPhaseCurrents;
    657          }
    658          
    659          /**
    660          * @brief  It computes and return latest converted motor phase currents motor
    661          * @param  this: related object of class CIHD2_PWMC
    662          * @retval Ia and Ib current in Curr_Components format
    663          */
    664          static void IHD2_GetPhaseCurrents(CPWMC this,Curr_Components* pStator_Currents)
    665          {
    666            int32_t wAux;
    667            uint16_t hReg;
    668            /* Derived class members container */
    669            pDVars_t pDVars_str = &DCLASS_VARS;  
    670          
    671            /* Reset the SOFOC flag to indicate the start of FOC algorithm*/
    672            pDVars_str->hFlags &= (~SOFOC); 
    673            
    674           /* Ia = (hPhaseAOffset)-(PHASE_A_ADC_CHANNEL vale)  */
    675            hReg = (uint16_t)((ADC1->JDR1)<<1);
    676            wAux = (int32_t)(hReg)-(int32_t)(pDVars_str->wPhaseAOffset);
    677            
    678           /* Saturation of Ia */
    679            if (wAux < S16_MIN)
    680            {
    681              pStator_Currents->qI_Component1= S16_MIN;
    682            }  
    683            else  if (wAux > S16_MAX)
    684                  { 
    685                    pStator_Currents->qI_Component1= S16_MAX;
    686                  }
    687                  else
    688                  {
    689                    pStator_Currents->qI_Component1= (int16_t)wAux;
    690                  }
    691                               
    692           /* Ib = (hPhaseBOffset)-(PHASE_B_ADC_CHANNEL value) */
    693            hReg = (uint16_t)((ADC2->JDR1)<<1);
    694            wAux = (int32_t)(hReg)-(int32_t)(pDVars_str->wPhaseBOffset);
    695            
    696           /* Saturation of Ib */
    697            if (wAux < S16_MIN)
    698            {
    699              pStator_Currents->qI_Component2= S16_MIN;
    700            }  
    701            else  if (wAux > S16_MAX)
    702                  { 
    703                    pStator_Currents->qI_Component2= S16_MAX;
    704                  }
    705                  else
    706                  {
    707                    pStator_Currents->qI_Component2= (int16_t)wAux;
    708                  }
    709          }
    710          
    711          
    712          /**
    713          * @brief  It sum up injected conversion data into wPhaseXOffset. It is called 
    714          *         only during current calibration 
    715          * @param  this: related object of class CIHD2_PWMC
    716          * @retval It always returns {0,0} in Curr_Components format
    717          */
    718          static void IHD2_HFCurrentsCalibration(CPWMC this,Curr_Components* pStator_Currents)
    719          { 
    720            /* Derived class members container */
    721            pDVars_t pDVars_str = &DCLASS_VARS; 
    722          
    723           /* Reset the SOFOC flag to indicate the start of FOC algorithm*/
    724            pDVars_str->hFlags &= (~SOFOC); 
    725              
    726            if (pDVars_str->bIndex < NB_CONVERSIONS)
    727            {
    728              pDVars_str-> wPhaseAOffset += ADC1->JDR1;
    729              pDVars_str-> wPhaseBOffset += ADC2->JDR1; 
    730              pDVars_str->bIndex++;
    731            }
    732          }
    733          
    734          /**
    735            * @brief  It turns on low sides switches. This function is intended to be 
    736            *         used for charging boot capacitors of driving section. It has to be 
    737            *         called each motor start-up when using high voltage drivers
    738            * @param  this: related object of class CIHD2_PWMC
    739            * @retval none
    740            */
    741          static void IHD2_TurnOnLowSides(CPWMC this)
    742          {
    743            pDParams_t pLocalDParams = DCLASS_PARAMS;
    744            TIM_TypeDef*  LocalTIMx = DCLASS_PARAMS->TIMx;  
    745            pDVars_t pDVars_str = &DCLASS_VARS;  
    746          
    747            /*Turn on the three low side switches */
    748            LocalTIMx->CCR1 = 0u;
    749            LocalTIMx->CCR2 = 0u;
    750            LocalTIMx->CCR3 = 0u;
    751            /*Disable ADC trigger */
    752            LocalTIMx->CCMR2 =0x7068u;
    753            LocalTIMx->CCR4 = pDVars_str->Half_PWMPeriod+1u;
    754            
    755            pDVars_str->hFlags &= (~SOFOC);
    756            
    757            TIM_ClearFlag(LocalTIMx,TIM_FLAG_Update);
    758            while (TIM_GetFlagStatus(LocalTIMx,TIM_FLAG_Update) == RESET)
    759            {}
    760            
    761            /* Main PWM Output Enable */
    762            TIM_CtrlPWMOutputs(LocalTIMx, ENABLE);
    763            if ((pLocalDParams->LowSideOutputs)== ES_GPIO)
    764            {
    765              GPIO_WriteBit(pLocalDParams->hCh1NPort, pLocalDParams->hCh1NPin, Bit_SET);
    766              GPIO_WriteBit(pLocalDParams->hCh2NPort, pLocalDParams->hCh2NPin, Bit_SET);
    767              GPIO_WriteBit(pLocalDParams->hCh3NPort, pLocalDParams->hCh3NPin, Bit_SET);
    768            }
    769            return; 
    770          }
    771          
    772          
    773          /**
    774          * @brief  It enables PWM generation on the proper Timer peripheral acting on MOE
    775          *         bit
    776          * @param  this: related object of class CIHD2_PWMC
    777          * @retval none
    778          */
    779          static void IHD2_SwitchOnPWM(CPWMC this)
    780          {  
    781            pDParams_t pLocalDParams = DCLASS_PARAMS;
    782            TIM_TypeDef*  LocalTIMx = DCLASS_PARAMS->TIMx;  
    783            pDVars_t pDVars_str = &DCLASS_VARS;  
    784           
    785            /* It clears ADCs JSTRT and JEOC bits */
    786            ADC1->SR &= ~ADC_SR_MASK;
    787            ADC2->SR &= ~ADC_SR_MASK;
    788            
    789            /* Clear Update Flag */
    790            TIM_ClearFlag(LocalTIMx, TIM_FLAG_Update);
    791            
    792            /* Enable TIMx preload and ADC trigger on next update */
    793            LocalTIMx->CCMR2 = 0x7868u;
    794            LocalTIMx->CCR4 = pDVars_str->Half_PWMPeriod-5u;
    795            
    796            TIM_ITConfig(LocalTIMx, TIM_IT_Update, ENABLE);
    797            
    798            /* Main PWM Output Disable */
    799            TIM_CtrlPWMOutputs(LocalTIMx, ENABLE);
    800            if ((pLocalDParams->LowSideOutputs)== ES_GPIO)
    801            {
    802              GPIO_WriteBit(pLocalDParams->hCh1NPort, pLocalDParams->hCh1NPin, Bit_SET);
    803              GPIO_WriteBit(pLocalDParams->hCh2NPort, pLocalDParams->hCh2NPin, Bit_SET);
    804              GPIO_WriteBit(pLocalDParams->hCh3NPort, pLocalDParams->hCh3NPin, Bit_SET);
    805            }
    806            
    807            pDVars_str->hFlags &= (~SOFOC);
    808            return; 
    809          }
    810          
    811          
    812          /**
    813          * @brief  It disables PWM generation on the proper Timer peripheral acting on 
    814          *         MOE bit
    815          * @param  this: related object of class CIHD2_PWMC
    816          * @retval none
    817          */
    818          static void IHD2_SwitchOffPWM(CPWMC this)
    819          { 
    820            pDParams_t pLocalDParams = DCLASS_PARAMS;
    821            TIM_TypeDef*  LocalTIMx = DCLASS_PARAMS->TIMx;
    822            pDVars_t pDVars_str = &DCLASS_VARS;  
    823            
    824              /* Disable UPDATE ISR */
    825            TIM_ITConfig(LocalTIMx, TIM_IT_Update, DISABLE);  
    826            
    827            LocalTIMx->CCER &= (uint16_t)(~TIMxCCER_MASK_CH123);
    828            
    829            while (TIM_GetFlagStatus(LocalTIMx,TIM_FLAG_Update)==RESET)
    830            {
    831              if (LocalTIMx->DIER & TIM_IT_Update)
    832              { break;}
    833            }
    834             
    835              /* Main PWM Output Disable */
    836            TIM_CtrlPWMOutputs(LocalTIMx, DISABLE);
    837            if ((pLocalDParams->LowSideOutputs)== ES_GPIO)
    838            {
    839              GPIO_WriteBit(pLocalDParams->hCh1NPort, pLocalDParams->hCh1NPin, Bit_RESET);
    840              GPIO_WriteBit(pLocalDParams->hCh2NPort, pLocalDParams->hCh2NPin, Bit_RESET);
    841              GPIO_WriteBit(pLocalDParams->hCh3NPort, pLocalDParams->hCh3NPin, Bit_RESET);
    842            }
    843            LocalTIMx->CCER |= TIMxCCER_MASK_CH123; 
    844            
    845            LocalTIMx->CCMR2 =0x7068u;
    846            LocalTIMx->CCR4 = pDVars_str->Half_PWMPeriod+1u;  
    847            
    848            return; 
    849          }
    850          
    851          /**
    852          * @brief  It stores into 'this' object variables the voltage present on Ia and 
    853          *         Ib current feedback analog channels when no current is flowin into the
    854          *         motor
    855          * @param  this: related object of class CIHD2_PWMC
    856          * @retval none
    857          */
    858          static uint16_t IHD2_WriteTIMRegisters(CPWMC this)
    859          {
    860            uint16_t hAux;
    861            TIM_TypeDef*  LocalTIMx = DCLASS_PARAMS->TIMx;
    862            /* Derived class members container */
    863            pDVars_t pDVars_str = &DCLASS_VARS;  
    864              
    865            LocalTIMx->CCR1 = ((_CPWMC) this)->Vars_str.hCntPhA;
    866            LocalTIMx->CCR2 = ((_CPWMC) this)->Vars_str.hCntPhB;
    867            LocalTIMx->CCR3 =((_CPWMC) this)->Vars_str.hCntPhC;
    868            
    869            /* Disable TIMx preload */  
    870            LocalTIMx->CCMR2 =0x7068u;
    871            LocalTIMx->CCR4 = pDVars_str->Half_PWMPeriod+1u;
    872            /* Enable TIMx preload */
    873            LocalTIMx->CCMR2 = 0x7868u;
    874            LocalTIMx->CCR4 = pDVars_str->Half_PWMPeriod-5u;
    875            
    876             /* Limit for update event */
    877            /* Check the status of SOFOC flag. If it is set, an update event has occurred 
    878            and thus the FOC rate is too high */
    879            if ((pDVars_str->hFlags & SOFOC) != 0u)
    880            {
    881              hAux = MC_FOC_DURATION;
    882            }
    883            else
    884            {
    885              hAux = MC_NO_ERROR;
    886            }
    887            return hAux;
    888          }
    889          
    890          
    891          
    892          /**
    893          * @brief  It contains the TIMx Update event interrupt
    894          * @param  this: related object of class CIHD2_PWMC
    895          * @retval none
    896          */
    897          static void *IHD2_IRQHandler(void *this, unsigned char flag)
    898          {
    899            uint32_t wADCInjFlags;
    900            pVars_t pVars_str = &CLASS_VARS;
    901            pDParams_t pDParams_str = DCLASS_PARAMS;
    902            TIM_TypeDef*  LocalTIMx = DCLASS_PARAMS->TIMx; 
    903            pDVars_t pDVars_str = &DCLASS_VARS;  
    904            
    905           wADCInjFlags = (ADC1-> SR) & ADC_SR_MASK;
    906           
    907          if (wADCInjFlags == CONV_STARTED)
    908           {
    909             do
    910             {
    911                wADCInjFlags = (ADC1-> SR) & ADC_SR_MASK;
    912             }
    913             while (wADCInjFlags != CONV_FINISHED);
    914           }
    915          else if (wADCInjFlags == FLAGS_CLEARED)
    916          {
    917            while ((LocalTIMx->CNT) < (pDParams_str->Tw))
    918            {}
    919            wADCInjFlags = (ADC1-> SR) & ADC_SR_MASK;
    920            
    921            if (wADCInjFlags == CONV_STARTED)
    922           {
    923             do
    924             {
    925                wADCInjFlags = (ADC1-> SR) & ADC_SR_MASK;
    926             }
    927             while (wADCInjFlags != CONV_FINISHED);
    928           }
    929          }
    930          else {}
    931          
    932          /* Set the SOFOC flag to indicate the execution of Update IRQ*/
    933          pDVars_str->hFlags |= SOFOC;
    934          
    935          /* Switch Context */
    936          /* It re-initilize AD converter in run time when using dual MC */
    937          if(LocalTIMx == TIM8)
    938          { 
    939            /* ADCx Injected conversions trigger is swithced to TIM8 CH4  
    940            ADC_ExternalTrigInjectedConvConfig(ADC2, ADC_ExternalTrigInjecConv_Ext_IT15_TIM8_CC4);*/ 
    941          
    942            ADC1->CR2 = 0x1EE901u;
    943            ADC2->CR2 = 0x1EE901u;
    944          }
    945          else
    946          { 
    947            /* ADCx Injected conversions trigger is swithced to TIM8 CH4  
    948            ADC_ExternalTrigInjectedConvConfig(ADC2, ADC_ExternalTrigInjecConv_T1_CC4);*/ 
    949              ADC1->CR2 = 0x1E9901u;
    950              ADC2->CR2 = 0x1E9901u;
    951          }
    952          /* Change channels keeping equal to 1 element the sequencer lenght */ 
    953          ADC1->JSQR = (uint32_t)(pDParams_str->bIaChannel)<<15;
    954          ADC2->JSQR = (uint32_t)(pDParams_str->bIbChannel)<<15;  
    955          
    956          return &(pVars_str->bMotor);
    957          }
    958          
    959          /**
    960          * @brief  Execute a regular conversion using ADC1. 
    961          *         The function is not re-entrant (can't executed twice at the same time)
    962          * @param  this related object of class CIHD2_PWMC
    963          * @retval It returns converted value or oxFFFF for conversion error
    964          */
    965          static uint16_t IHD2_ExecRegularConv(CPWMC this, uint8_t bChannel)
    966          {
    967            pDVars_t pDVars_str = &DCLASS_VARS;
    968            uint32_t tmpflag = 0u;
    969          
    970            ADC1->SQR3 = bChannel;
    971            
    972            DMA1_Channel1->CMAR=(uint32_t)(&(pDVars_str->hRegConv));
    973            
    974            /* Reset DMA1_CH1 TC Flag */
    975            DMA1->IFCR = DMA1_FLAG_TC1;
    976            
    977            /* It starts software triggered regular conversion
    978            through bit banding access. It is equivalent to 
    979            ADC1->CR2 |= EXTTRIG_SWSTART_Set; */
    980            *(uint32_t *)(ADC1_CR2_EXTTRIG_SWSTART_BB)=(uint32_t)(0x1u);
    981            
    982            /* Wait until end of regular conversion */
    983            while (tmpflag == 0u)
    984            {
    985              tmpflag = (DMA1->ISR & DMA1_FLAG_TC1);
    986            }
    987           
    988            return (pDVars_str->hRegConv);
    989          }
    990          
    991          /**
    992          * @brief  It sets the specified sampling time for the specified ADC channel
    993          *         on ADC1. It must be called once for each channel utilized by user
    994          * @param  ADC channel, sampling time
    995          * @retval none
    996          */
    997          static void IHD2_ADC_SetSamplingTime(CPWMC this, ADConv_t ADConv_struct)
    998          { 
    999             uint32_t tmpreg1 = 0u, tmpreg2 = 0u, tmpreg3=0u, tmpreg4 = SMPR1_SMP_Set;
   1000             
   1001            /* if ADC_Channel_10 ... ADC_Channel_17 is selected */
   1002            if (ADConv_struct.Channel> ADC_Channel_9)
   1003            {
   1004              /* Get the old register value */
   1005              tmpreg1 = ADC1->SMPR1;
   1006              /* Calculate the mask to clear */
   1007              tmpreg3 = (uint32_t) (ADConv_struct.Channel) - 10u;
   1008              tmpreg3 = tmpreg3 *3u;
   1009              tmpreg2 =  tmpreg4 << (tmpreg3);
   1010              /* Clear the old discontinuous mode channel count */
   1011              tmpreg1 &= ~tmpreg2;
   1012              /* Calculate the mask to set */
   1013              tmpreg2 = (uint32_t)(ADConv_struct.SamplTime) << (tmpreg3);
   1014              /* Set the discontinuous mode channel count */
   1015              tmpreg1 |= tmpreg2;
   1016              /* Store the new register value */
   1017              ADC1->SMPR1 = tmpreg1;
   1018            }
   1019            else /* ADC_Channel include in ADC_Channel_[0..9] */
   1020            {
   1021              /* Get the old register value */
   1022              tmpreg1 = ADC1->SMPR2;
   1023              tmpreg3 = (uint32_t) (ADConv_struct.Channel) * 3u;
   1024              /* Calculate the mask to clear */
   1025              tmpreg4 = SMPR2_SMP_Set;
   1026              tmpreg2 =  tmpreg4 << (tmpreg3);
   1027              /* Clear the old discontinuous mode channel count */
   1028              tmpreg1 &= ~tmpreg2;
   1029              /* Calculate the mask to set */
   1030              tmpreg2 = (uint32_t)(ADConv_struct.SamplTime) << (tmpreg3);
   1031              /* Set the discontinuous mode channel count */
   1032              tmpreg1 |= tmpreg2;
   1033              /* Store the new register value */
   1034              ADC1->SMPR2 = tmpreg1;
   1035            }
   1036          }
   1037          
   1038          /**
   1039          * @brief  It is used to check if an overcurrent occurred since last call.
   1040          * @param  this related object of class CPWMC
   1041          * @retval uint16_t It returns MC_BREAK_IN whether an overcurrent has been 
   1042          *                  detected since last method call, MC_NO_FAULTS otherwise.
   1043          */
   1044          static uint16_t IHD2_IsOverCurrentOccurred(CPWMC this)
   1045          {
   1046            TIM_TypeDef*  LocalTIMx = DCLASS_PARAMS->TIMx;
   1047            uint16_t retVal = MC_NO_FAULTS;
   1048            if ((LocalTIMx->SR & TIM_FLAG_Break) != 0u)
   1049            {
   1050              retVal = MC_BREAK_IN;
   1051              LocalTIMx->SR = (u16)~TIM_FLAG_Break;
   1052            }
   1053            return retVal;
   1054          }
   1055          
   1056          /**
   1057          * @}
   1058          */
   1059          
   1060          /**
   1061          * @}
   1062          */
   1063          
   1064          /**
   1065          * @}
   1066          */
   1067          
   1068          #endif
   1069          
   1070          /******************* (C) COPYRIGHT 2016 STMicroelectronics *****END OF FILE****/


 

 


Errors: none
Warnings: none
