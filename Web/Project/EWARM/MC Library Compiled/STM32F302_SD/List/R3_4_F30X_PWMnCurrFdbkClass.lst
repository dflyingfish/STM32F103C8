###############################################################################
#
# IAR ANSI C/C++ Compiler V7.60.1.11101/W32 for ARM       24/Mar/2017  23:55:39
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\FOC 4.3\v4.3.0\STM32 PMSM FOC
#        LIB\Web\MCLibrary\src\R3_4_F30X_PWMnCurrFdbkClass.c
#    Command line =  
#        "F:\FOC 4.3\v4.3.0\STM32 PMSM FOC
#        LIB\Web\MCLibrary\src\R3_4_F30X_PWMnCurrFdbkClass.c" -D
#        USE_STDPERIPH_DRIVER -D STM32F30X -D MC_LIBRARY_SINGLE -D ARM_MATH_CM4
#        -lcN "F:\FOC 4.3\v4.3.0\STM32 PMSM FOC LIB\Web\Project\EWARM\MC
#        Library Compiled\STM32F302_SD\List" -o "F:\FOC 4.3\v4.3.0\STM32 PMSM
#        FOC LIB\Web\Project\EWARM\MC Library Compiled\STM32F302_SD\Obj"
#        --debug --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp
#        --dlib_config "D:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.4\arm\INC\c\DLib_Config_Normal.h" -I "F:\FOC 4.3\v4.3.0\STM32 PMSM
#        FOC LIB\Web\Project\EWARM\..\" -I "F:\FOC 4.3\v4.3.0\STM32 PMSM FOC
#        LIB\Web\Project\EWARM\..\..\MCLibrary\" -I "F:\FOC 4.3\v4.3.0\STM32
#        PMSM FOC LIB\Web\Project\EWARM\..\..\MCLibrary\inc\" -I "F:\FOC
#        4.3\v4.3.0\STM32 PMSM FOC
#        LIB\Web\Project\EWARM\..\..\MCLibrary\protected_sources\inc\" -I
#        "F:\FOC 4.3\v4.3.0\STM32 PMSM FOC
#        LIB\Web\Project\EWARM\..\..\MCLibrary\interface\" -I "F:\FOC
#        4.3\v4.3.0\STM32 PMSM FOC
#        LIB\Web\Project\EWARM\..\..\MCLibrary\interface\common\" -I "F:\FOC
#        4.3\v4.3.0\STM32 PMSM FOC
#        LIB\Web\Project\EWARM\..\..\..\Common\Libraries\CMSIS\CMSIS_2_x\Device\ST\STM32F30x\Include\"
#        -I "F:\FOC 4.3\v4.3.0\STM32 PMSM FOC
#        LIB\Web\Project\EWARM\..\..\..\Common\Libraries\STM32F30x_StdPeriph_Driver\inc\"
#        -Oh --use_c++_inline -I "D:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.4\arm\CMSIS\Include\"
#    Locale       =  C
#    List file    =  
#        F:\FOC 4.3\v4.3.0\STM32 PMSM FOC LIB\Web\Project\EWARM\MC Library
#        Compiled\STM32F302_SD\List\R3_4_F30X_PWMnCurrFdbkClass.lst
#    Object file  =  
#        F:\FOC 4.3\v4.3.0\STM32 PMSM FOC LIB\Web\Project\EWARM\MC Library
#        Compiled\STM32F302_SD\Obj\R3_4_F30X_PWMnCurrFdbkClass.o
#
###############################################################################

F:\FOC 4.3\v4.3.0\STM32 PMSM FOC LIB\Web\MCLibrary\src\R3_4_F30X_PWMnCurrFdbkClass.c
      1          /**
      2            ******************************************************************************
      3            * @file    R3_4_F30X_PWMnCurrFdbkClass.c
      4            * @author  STMicroelectronics - System Lab - MC Team
      5            * @version 4.3.0
      6            * @date    22-Sep-2016 15:29
      7            * @brief   This file contains implementation of current sensor class to be
      8            *          instantiated when the three shunts current sensing topology is 
      9            *          used.
     10            *          It is specifically designed for STM32F30x microcontrollers and
     11            *          implements the simultaneous dual sampling method using separate
     12            *          resource for each motor drives (OPAMPs and ADCs).           
     13            ******************************************************************************
     14            * @attention
     15            *
     16            * <h2><center>&copy; COPYRIGHT 2016 STMicroelectronics</center></h2>
     17            *
     18            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     19            * You may not use this file except in compliance with the License.
     20            * You may obtain a copy of the License at:
     21            *
     22            *        http://www.st.com/software_license_agreement_liberty_v2
     23            *
     24            * Unless required by applicable law or agreed to in writing, software 
     25            * distributed under the License is distributed on an "AS IS" BASIS, 
     26            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     27            * See the License for the specific language governing permissions and
     28            * limitations under the License.
     29            *
     30            ******************************************************************************
     31            */
     32          
     33          /* Includes ------------------------------------------------------------------*/
     34          #include "PWMnCurrFdbkClass.h"
     35          #include "PWMnCurrFdbkPrivate.h"
     36          #include "R3_4_F30X_PWMnCurrFdbkClass.h"
     37          #include "R3_4_F30X_PWMnCurrFdbkPrivate.h"
     38          #include "MCIRQHandlerClass.h"
     39          #include "MCIRQHandlerPrivate.h"
     40          #include "MCLibraryConf.h"
     41          #include "MCLibraryISRPriorityConf.h"
     42          #include "MC_type.h"
     43          
     44          #define TIMxCCER_MASK_CH123        ((uint32_t)  0x00000555u)
     45          
     46          #define NB_CONVERSIONS 16u
     47          
     48          #define CLASS_VARS   ((_CPWMC)this)->Vars_str
     49          #define CLASS_PARAMS ((_CPWMC)this)->pParams_str
     50          #define DCLASS_PARAMS ((_DCR3_4_F30X_PWMC)(((_CPWMC) this)->DerivedClass))->pDParams_str
     51          #define DCLASS_VARS  ((_DCR3_4_F30X_PWMC)(((_CPWMC) this)->DerivedClass))->DVars_str
     52          
     53          #define PWM_PERIOD pLocalVars_Str->Half_PWMPeriod
     54          
     55          #define CCMR2_CH4_DISABLE 0x8FFFu
     56          #define CCMR2_CH4_PWM1    0x6000u
     57          #define CCMR2_CH4_PWM2    0x7000u
     58          
     59          #define OPAMP_CSR_DEFAULT_MASK  ((uint32_t)0xFFFFFF93u)
     60          
     61          #ifdef MC_CLASS_DYNAMIC
     62          #include "stdlib.h" /* Used for dynamic allocation */
     63          #else
     64          _DCR3_4_F30X_PWMC_t R3_4_F30X_PWMCpool[MAX_DRV_PWMC_NUM];
     65          unsigned char R3_4_F30X_PWMC_Allocated = 0u;
     66          #endif
     67          
     68          /** 
     69            * @brief  BDTR structure definition 
     70            * @note   This extend the STD lib structure to set also
     71          	*         BKIN2 enable/disable
     72          	*         BKIN2 polarity
     73          	*         BKIN  Filter
     74          	*         BKIN2 Filter
     75            *         It must be used with the fucntion TIM_BDTRConfig_MC
     76            */
     77          typedef struct
     78          {
     79            
     80            uint16_t TIM_OSSRState;        /*!< Specifies the Off-State selection used in Run mode.
     81                                                This parameter can be a value of @ref TIM_OSSR_Off_State_Selection_for_Run_mode_state */
     82          
     83            uint16_t TIM_OSSIState;        /*!< Specifies the Off-State used in Idle state.
     84                                                This parameter can be a value of @ref TIM_OSSI_Off_State_Selection_for_Idle_mode_state */
     85          
     86            uint16_t TIM_LOCKLevel;        /*!< Specifies the LOCK level parameters.
     87                                                This parameter can be a value of @ref TIM_Lock_level */ 
     88          
     89            uint16_t TIM_DeadTime;         /*!< Specifies the delay time between the switching-off and the
     90                                                switching-on of the outputs.
     91                                                This parameter can be a number between 0x00 and 0xFF  */
     92          
     93            uint32_t TIM_Break;            /*!< Specifies whether the TIM Break input is enabled or not. 
     94                                                This parameter can be a value of @ref TIM_Break1_Input_enable_disable */
     95          
     96            uint32_t TIM_BreakPolarity;    /*!< Specifies the TIM Break Input pin polarity.
     97                                                This parameter can be a value of @ref TIM_Break_Polarity */
     98          
     99            uint16_t TIM_AutomaticOutput;  /*!< Specifies whether the TIM Automatic Output feature is enabled or not. 
    100                                                This parameter can be a value of @ref TIM_AOE_Bit_Set_Reset */
    101            uint32_t TIM_Break2;           /*!< Specifies whether the TIM Break input is enabled or not. 
    102                                                This parameter can be a value of @ref TIM_Break2_Input_enable_disable */
    103            uint32_t TIM_Break2Polarity;   /*!< specifies the Break2 polarity.
    104                                                This parameter can be one of the following values:
    105                                                @arg TIM_Break2Polarity_Low: Break2 input is active low
    106                                                @arg TIM_Break2Polarity_High: Break2 input is active high */
    107            uint8_t TIM_Break1Filter;      /*!< Specifies the Break1 filter value.
    108                                                This parameter must be a value between 0x00 and 0x0F */
    109            uint8_t TIM_Break2Filter;      /*!< Specifies the Break2 filter value.
    110                                                This parameter must be a value between 0x00 and 0x0F */
    111          } TIM_BDTRInitTypeDef_MC;
    112          
    113          /* These function overloads the TIM_BDTRConfig and TIM_BDTRStructInit
    114             of the standard library */
    115          static void TIM_BDTRConfig_MC(TIM_TypeDef* TIMx, TIM_BDTRInitTypeDef_MC *TIM_BDTRInitStruct);
    116          static void TIM_BDTRStructInit_MC(TIM_BDTRInitTypeDef_MC* TIM_BDTRInitStruct);
    117          
    118          static void R3_4_F30X_Init(CPWMC this);
    119          static void R3_4_F30X_TIMxInit(TIM_TypeDef* TIMx, CPWMC this);
    120          static void R3_4_F30X_CurrentReadingCalibration(CPWMC this);
    121          static void R3_4_F30X_GetPhaseCurrents(CPWMC this,Curr_Components* pStator_Currents);
    122          static void R3_4_F30X_TurnOnLowSides(CPWMC this);
    123          static void R3_4_F30X_SwitchOnPWM(CPWMC this);
    124          static void R3_4_F30X_SwitchOffPWM(CPWMC this);
    125          static uint16_t R3_4_F30X_WriteTIMRegisters(CPWMC this);
    126          static uint16_t R3_4_F30X_SetADCSampPointSect1(CPWMC this);
    127          static uint16_t R3_4_F30X_SetADCSampPointSect2(CPWMC this);
    128          static uint16_t R3_4_F30X_SetADCSampPointSect3(CPWMC this);
    129          static uint16_t R3_4_F30X_SetADCSampPointSect4(CPWMC this);
    130          static uint16_t R3_4_F30X_SetADCSampPointSect5(CPWMC this);
    131          static uint16_t R3_4_F30X_SetADCSampPointSect6(CPWMC this);
    132          static uint16_t R3_4_F30X_SetADCSampPointCalibration(CPWMC this);
    133          static void *R3_4_F30X_IRQHandler(void *this, unsigned char flag);
    134          static uint16_t R3_4_F30X_ExecRegularConv(CPWMC this, uint8_t bChannel);
    135          static void R3_4_F30X_ADC_SetSamplingTime(CPWMC this, ADConv_t ADConv_struct);
    136          static void R3_4_F30X_HFCurrentsCalibrationAB(CPWMC this,Curr_Components* pStator_Currents);
    137          static void R3_4_F30X_HFCurrentsCalibrationC(CPWMC this,Curr_Components* pStator_Currents);
    138          static uint16_t R3_4_F30X_IsOverCurrentOccurred(CPWMC this);
    139          static void R3_4_F30X_SetAOReferenceVoltage(uint32_t DAC_Channel, uint16_t hDACVref);
    140          static uint16_t F30X_GPIOPin2Source(uint16_t GPIO_Pin);
    141          uint32_t R3_4_F30X_ADC_InjectedChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime, uint8_t SequencerLength, uint16_t ADC_ExternalTriggerInjectedPolarity, uint16_t ADC_ExternalTriggerInjected);
    142          uint32_t R3_4_F30X_OPAMP_Init(uint32_t OPAMP_Selection, OPAMP_InitTypeDef* OPAMP_InitStruct);
    143          static void R3_4_F30X_RLDetectionModeEnable(CPWMC this);
    144          static void R3_4_F30X_RLDetectionModeDisable(CPWMC this);
    145          static uint16_t R3_4_F30X_RLDetectionModeSetDuty(CPWMC this, uint16_t hDuty);
    146          static void R3_4_F30X_RLGetPhaseCurrents(CPWMC this,Curr_Components* pStator_Currents);
    147          static void R3_4_F30X_RLTurnOnLowSides(CPWMC this);
    148          static void R3_4_F30X_RLSwitchOnPWM(CPWMC this);
    149          static void R3_4_F30X_RLSwitchOffPWM(CPWMC this);
    150          
    151          /**
    152          * @brief  Creates an object of the class R3_4_F30X
    153          * @param  pPWMnCurrFdbkParams pointer to an PWMnCurrFdbk parameters structure
    154          * @param  pR3_DDParams pointer to an R3_DD parameters structure
    155          * @retval CR3_4_F30X_PWMC new instance of R3_4_F30X object
    156          */
    157          CR3_4_F30X_PWMC R3_4_F3XX_NewObject(pPWMnCurrFdbkParams_t pPWMnCurrFdbkParams, 
    158                                              pR3_4_F30XParams_t pR3_4_F30XParams)
    159          {
    160            _CPWMC _oPWMnCurrFdbk;
    161            _DCR3_4_F30X_PWMC _oR3_4_F30X;
    162            
    163            _oPWMnCurrFdbk = (_CPWMC)PWMC_NewObject(pPWMnCurrFdbkParams);
    164            
    165          #ifdef MC_CLASS_DYNAMIC
    166            _oR3_4_F30X = (_DCR3_4_F30X_PWMC)calloc(1u,sizeof(_DCR3_4_F30X_PWMC_t));
    167          #else
    168            if (R3_4_F30X_PWMC_Allocated  < MAX_DRV_PWMC_NUM)
    169            {
    170              _oR3_4_F30X = &R3_4_F30X_PWMCpool[R3_4_F30X_PWMC_Allocated++];
    171            }
    172            else
    173            {
    174              _oR3_4_F30X = MC_NULL;
    175            }
    176          #endif
    177            
    178            _oR3_4_F30X->pDParams_str = pR3_4_F30XParams;
    179            _oPWMnCurrFdbk->DerivedClass = (void*)_oR3_4_F30X;
    180            
    181            _oPWMnCurrFdbk->Methods_str.pIRQ_Handler = &R3_4_F30X_IRQHandler;
    182            
    183            Set_IRQ_Handler(pR3_4_F30XParams->IRQnb, (_CMCIRQ)_oPWMnCurrFdbk);
    184            
    185            _oPWMnCurrFdbk->Methods_str.pPWMC_Init = &R3_4_F30X_Init;
    186            _oPWMnCurrFdbk->Methods_str.pPWMC_GetPhaseCurrents = &R3_4_F30X_GetPhaseCurrents;
    187            _oPWMnCurrFdbk->Methods_str.pPWMC_SwitchOffPWM = &R3_4_F30X_SwitchOffPWM;
    188            _oPWMnCurrFdbk->Methods_str.pPWMC_SwitchOnPWM = &R3_4_F30X_SwitchOnPWM;        
    189            _oPWMnCurrFdbk->Methods_str.pPWMC_CurrentReadingCalibr = 
    190                                                           &R3_4_F30X_CurrentReadingCalibration;         
    191            _oPWMnCurrFdbk->Methods_str.pPWMC_TurnOnLowSides = &R3_4_F30X_TurnOnLowSides;         
    192            _oPWMnCurrFdbk->Methods_str.pPWMC_SetADCSampPointSect1 = 
    193                                                                &R3_4_F30X_SetADCSampPointSect1;
    194            _oPWMnCurrFdbk->Methods_str.pPWMC_SetADCSampPointSect2 = 
    195                                                                &R3_4_F30X_SetADCSampPointSect2;
    196            _oPWMnCurrFdbk->Methods_str.pPWMC_SetADCSampPointSect3 = 
    197                                                                &R3_4_F30X_SetADCSampPointSect3;
    198            _oPWMnCurrFdbk->Methods_str.pPWMC_SetADCSampPointSect4 = 
    199                                                                &R3_4_F30X_SetADCSampPointSect4;
    200            _oPWMnCurrFdbk->Methods_str.pPWMC_SetADCSampPointSect5 = 
    201                                                                &R3_4_F30X_SetADCSampPointSect5;
    202            _oPWMnCurrFdbk->Methods_str.pPWMC_SetADCSampPointSect6 = 
    203                                                                &R3_4_F30X_SetADCSampPointSect6;
    204            _oPWMnCurrFdbk->Methods_str.pPWMC_ExecRegularConv= &R3_4_F30X_ExecRegularConv;
    205            
    206            _oPWMnCurrFdbk->Methods_str.pPWMC_SetSamplingTime= &R3_4_F30X_ADC_SetSamplingTime;
    207            
    208            _oPWMnCurrFdbk->Methods_str.pPWMC_IsOverCurrentOccurred = 
    209              &R3_4_F30X_IsOverCurrentOccurred;
    210            
    211            _oPWMnCurrFdbk->Methods_str.pRLDetectionModeEnable = &R3_4_F30X_RLDetectionModeEnable;
    212            
    213            _oPWMnCurrFdbk->Methods_str.pRLDetectionModeDisable = &R3_4_F30X_RLDetectionModeDisable;
    214            
    215            _oPWMnCurrFdbk->Methods_str.pRLDetectionModeSetDuty = &R3_4_F30X_RLDetectionModeSetDuty;
    216            
    217            return ((CR3_4_F30X_PWMC)_oPWMnCurrFdbk);
    218          }
    219          
    220          /** @addtogroup STM32F10x_PMSM_MC_Library
    221          * @{
    222          */
    223          
    224          /** @addtogroup PWMnCurrFdbk_R3_4_F30X
    225          * @{
    226          */
    227          
    228          /** @defgroup R3_4_F30X_class_private_methods R3_4_F30X class private methods
    229          * @{
    230          */
    231          
    232          /**
    233          * @brief  It initializes TIMx, ADC, GPIO, DMA1 and NVIC for current reading 
    234          *         in ICS configuration using STM32F103x High Density
    235          * @param  this: related object of class CR3_4_F30X_PWMC
    236          * @retval none
    237          */
    238          static void R3_4_F30X_Init(CPWMC this)
    239          {
    240            NVIC_InitTypeDef NVIC_InitStructure;
    241            GPIO_InitTypeDef GPIO_InitStructure;
    242            ADC_InitTypeDef ADC_InitStructure;
    243            ADC_CommonInitTypeDef ADC_CommonInitStructure;
    244            pVars_t pVars_str = &CLASS_VARS;
    245            pDVars_t pDVars_str = &DCLASS_VARS;  
    246            pDParams_t pDParams_str = DCLASS_PARAMS; 
    247            pR3_4_F30XOPAMPParams_t pDOPAMPParams_str = pDParams_str->pOPAMPParams;
    248            pF30XCOMPParams_t pDOCPA_COMPParams_str = pDParams_str->pOCPA_COMPParams;
    249            pF30XCOMPParams_t pDOCPB_COMPParams_str = pDParams_str->pOCPB_COMPParams;
    250            pF30XCOMPParams_t pDOCPC_COMPParams_str = pDParams_str->pOCPC_COMPParams;
    251            pF30XCOMPParams_t pDOVP_COMPParams_str  = pDParams_str->pOVP_COMPParams;
    252            TIM_TypeDef*  TIMx = pDParams_str->TIMx;
    253            ADC_TypeDef* ADCx_1;
    254            ADC_TypeDef* ADCx_2;
    255            uint8_t NVIC_IRQChannel;
    256            
    257            pVars_str->bMotor = (pDParams_str->bInstanceNbr==1u?M1:M2);
    258            pDVars_str->Half_PWMPeriod = ((((_CPWMC) this)->pParams_str->hPWMperiod)/2u);
    259              
    260            /* Peripheral clocks enabling ---------------------------------------------*/
    261            
    262            RCC->AHBENR |= RCC_AHBPeriph_CRC;
    263            
    264            /* ADC Periph clock enable */ 
    265            RCC_AHBPeriphClockCmd(pDParams_str->wAHBPeriph, ENABLE);
    266            
    267            /* Enable GPIOA-GPIOI clock */
    268            RCC_AHBPeriphClockCmd( RCC_AHBPeriph_GPIOA | 
    269                                   RCC_AHBPeriph_GPIOB | RCC_AHBPeriph_GPIOC | 
    270                                     RCC_AHBPeriph_GPIOD | RCC_AHBPeriph_GPIOE | 
    271                                       RCC_AHBPeriph_GPIOF, ENABLE);
    272            
    273            /* Enable TIM1 - TIM8 clock */
    274            if(TIMx == TIM1)
    275            {
    276              /* Enable TIM1 clock */
    277              RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM1, ENABLE);
    278          		/* Clock source is APB high speed clock*/
    279          		RCC_TIMCLKConfig(RCC_TIM1CLK_HCLK);
    280            }
    281            else
    282            {
    283              /* Enable TIM8 clock */
    284              RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM8, ENABLE);
    285          		/* Clock source is APB high speed clock*/
    286          		RCC_TIMCLKConfig(RCC_TIM8CLK_HCLK);
    287            }
    288            
    289            /* Enable the CCS */
    290            RCC_ClockSecuritySystemCmd((FunctionalState)(ENABLE));
    291          	
    292          	R3_4_F30X_TIMxInit(TIMx, this);
    293            
    294            /* GPIOs configurations --------------------------------------------------*/
    295            GPIO_StructInit(&GPIO_InitStructure);
    296            
    297            if (!pDOPAMPParams_str)
    298            {
    299              /****** Configure phase A ADC channel GPIO as analog input ****/
    300              GPIO_InitStructure.GPIO_Pin = pDParams_str->hIaPin;  
    301              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AN;
    302              GPIO_Init(pDParams_str->hIaPort,
    303                        &GPIO_InitStructure);
    304              GPIO_PinLockConfig(pDParams_str->hIaPort, pDParams_str->hIaPin);
    305              
    306              /****** Configure phase B ADC channel GPIO as analog input ****/
    307              GPIO_InitStructure.GPIO_Pin = pDParams_str->hIbPin;  
    308              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AN;
    309              GPIO_Init(pDParams_str->hIbPort, &GPIO_InitStructure);
    310              GPIO_PinLockConfig(pDParams_str->hIbPort, pDParams_str->hIbPin);
    311              
    312              /****** Configure phase C ADC channel GPIO as analog input ****/
    313              GPIO_InitStructure.GPIO_Pin = pDParams_str->hIcPin;  
    314              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AN;
    315              GPIO_Init(pDParams_str->hIcPort, &GPIO_InitStructure);
    316              GPIO_PinLockConfig(pDParams_str->hIcPort, pDParams_str->hIcPin);
    317            }
    318            
    319            /****** Configure TIMx Channel 1, 2 and 3 Outputs ******/ 
    320            GPIO_PinAFConfig(pDParams_str->hCh1Port, F30X_GPIOPin2Source(pDParams_str->hCh1Pin), pDParams_str->bCh1AF);
    321            GPIO_PinAFConfig(pDParams_str->hCh2Port, F30X_GPIOPin2Source(pDParams_str->hCh2Pin), pDParams_str->bCh2AF);
    322            GPIO_PinAFConfig(pDParams_str->hCh3Port, F30X_GPIOPin2Source(pDParams_str->hCh3Pin), pDParams_str->bCh3AF);
    323            
    324            GPIO_StructInit(&GPIO_InitStructure);
    325            
    326            GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    327            GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
    328            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
    329            GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    330            
    331            GPIO_InitStructure.GPIO_Pin = pDParams_str->hCh1Pin;
    332            GPIO_Init(pDParams_str->hCh1Port, &GPIO_InitStructure);
    333            GPIO_InitStructure.GPIO_Pin = pDParams_str->hCh2Pin;
    334            GPIO_Init(pDParams_str->hCh2Port, &GPIO_InitStructure);
    335            GPIO_InitStructure.GPIO_Pin = pDParams_str->hCh3Pin;
    336            GPIO_Init(pDParams_str->hCh3Port, &GPIO_InitStructure);
    337            
    338            GPIO_PinLockConfig(pDParams_str->hCh1Port, pDParams_str->hCh1Pin);
    339            GPIO_PinLockConfig(pDParams_str->hCh2Port, pDParams_str->hCh2Pin);
    340            GPIO_PinLockConfig(pDParams_str->hCh3Port, pDParams_str->hCh3Pin);
    341            
    342            /****** Configure TIMx Channel 1N, 2N and 3N Outputs, if enabled ******/    
    343            if ((pDParams_str->LowSideOutputs)== LS_PWM_TIMER) 
    344            { 
    345              GPIO_PinAFConfig(pDParams_str->hCh1NPort, F30X_GPIOPin2Source(pDParams_str->hCh1NPin), pDParams_str->bCh1NAF);
    346              GPIO_PinAFConfig(pDParams_str->hCh2NPort, F30X_GPIOPin2Source(pDParams_str->hCh2NPin), pDParams_str->bCh2NAF);
    347              GPIO_PinAFConfig(pDParams_str->hCh3NPort, F30X_GPIOPin2Source(pDParams_str->hCh3NPin), pDParams_str->bCh3NAF);
    348              
    349              GPIO_InitStructure.GPIO_Pin = pDParams_str->hCh1NPin;  
    350              GPIO_Init(pDParams_str->hCh1NPort, &GPIO_InitStructure);  
    351              GPIO_InitStructure.GPIO_Pin = pDParams_str->hCh2NPin;  
    352              GPIO_Init(pDParams_str->hCh2NPort, &GPIO_InitStructure);    
    353              GPIO_InitStructure.GPIO_Pin = pDParams_str->hCh3NPin;  
    354              GPIO_Init(pDParams_str->hCh3NPort, &GPIO_InitStructure);
    355              
    356              GPIO_PinLockConfig(pDParams_str->hCh1NPort, pDParams_str->hCh1NPin);
    357              GPIO_PinLockConfig(pDParams_str->hCh2NPort, pDParams_str->hCh2NPin);
    358              GPIO_PinLockConfig(pDParams_str->hCh3NPort, pDParams_str->hCh3NPin);
    359            }  
    360          	else if ((pDParams_str->LowSideOutputs)== ES_GPIO)
    361            {
    362              /* Only "active high" polarity is supported */
    363              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
    364              
    365              GPIO_InitStructure.GPIO_Pin = pDParams_str->hCh1NPin;
    366              GPIO_Init(pDParams_str->hCh1NPort, &GPIO_InitStructure);
    367              GPIO_InitStructure.GPIO_Pin = pDParams_str->hCh2NPin;
    368              GPIO_Init(pDParams_str->hCh2NPort, &GPIO_InitStructure);
    369              GPIO_InitStructure.GPIO_Pin = pDParams_str->hCh3NPin;
    370              GPIO_Init(pDParams_str->hCh3NPort, &GPIO_InitStructure);
    371              
    372              GPIO_PinLockConfig(pDParams_str->hCh1NPort, pDParams_str->hCh1NPin);
    373              GPIO_PinLockConfig(pDParams_str->hCh2NPort, pDParams_str->hCh2NPin);
    374              GPIO_PinLockConfig(pDParams_str->hCh3NPort, pDParams_str->hCh3NPin);
    375              
    376              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
    377            }
    378            else
    379            {
    380            }
    381            
    382            /****** Configure TIMx BKIN input, if enabled ******/
    383            if ((pDParams_str->bBKINMode) == EXT_MODE)
    384            {
    385              GPIO_PinAFConfig(pDParams_str->hBKINPort, F30X_GPIOPin2Source(pDParams_str->hBKINPin), pDParams_str->bBKINAF);
    386              GPIO_InitStructure.GPIO_Pin = pDParams_str->hBKINPin;  
    387              GPIO_Init(pDParams_str->hBKINPort, &GPIO_InitStructure); 
    388              GPIO_PinLockConfig(pDParams_str->hBKINPort, pDParams_str->hBKINPin);
    389            }
    390            
    391            /****** Configure TIMx BKIN2 input, if enabled ******/
    392            if ((pDParams_str->bBKIN2Mode) == EXT_MODE)
    393            {
    394              GPIO_PinAFConfig(pDParams_str->hBKIN2Port, F30X_GPIOPin2Source(pDParams_str->hBKIN2Pin), pDParams_str->bBKIN2AF);
    395              GPIO_InitStructure.GPIO_Pin = pDParams_str->hBKIN2Pin;  
    396              GPIO_Init(pDParams_str->hBKIN2Port, &GPIO_InitStructure); 
    397              GPIO_PinLockConfig(pDParams_str->hBKIN2Port, pDParams_str->hBKIN2Pin);
    398            }
    399            
    400            if(TIMx == TIM1)
    401            {   
    402              /* TIM1 Counter Clock stopped when the core is halted */
    403              DBGMCU_APB2PeriphConfig(DBGMCU_TIM1_STOP, ENABLE);
    404            }
    405            else
    406            {
    407              /* TIM8 Counter Clock stopped when the core is halted */
    408              DBGMCU_APB2PeriphConfig(DBGMCU_TIM8_STOP, ENABLE);
    409            }
    410            
    411            if (pDOPAMPParams_str)
    412            {
    413              OPAMP_InitTypeDef OPAMP_InitStruct;
    414              RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);
    415              
    416              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AN;
    417              GPIO_InitStructure.GPIO_Pin = pDOPAMPParams_str->hOPAMP_NonInvertingInput_PHA_GPIO_PIN;
    418              GPIO_Init(pDOPAMPParams_str->hOPAMP_NonInvertingInput_PHA_GPIO_PORT, &GPIO_InitStructure);
    419              GPIO_PinLockConfig(pDOPAMPParams_str->hOPAMP_NonInvertingInput_PHA_GPIO_PORT,
    420                                 pDOPAMPParams_str->hOPAMP_NonInvertingInput_PHA_GPIO_PIN);
    421              GPIO_InitStructure.GPIO_Pin = pDOPAMPParams_str->hOPAMP_NonInvertingInput_PHB_GPIO_PIN;
    422              GPIO_Init(pDOPAMPParams_str->hOPAMP_NonInvertingInput_PHB_GPIO_PORT, &GPIO_InitStructure);
    423              GPIO_PinLockConfig(pDOPAMPParams_str->hOPAMP_NonInvertingInput_PHB_GPIO_PORT,
    424                                 pDOPAMPParams_str->hOPAMP_NonInvertingInput_PHB_GPIO_PIN);
    425              if (pDOPAMPParams_str->bOPAMP_InvertingInput_MODE == EXT_MODE)
    426              {
    427                GPIO_InitStructure.GPIO_Pin = pDOPAMPParams_str->hOPAMP_InvertingInput_GPIO_PIN;
    428                GPIO_Init(pDOPAMPParams_str->hOPAMP_InvertingInput_GPIO_PORT, &GPIO_InitStructure);
    429                GPIO_PinLockConfig(pDOPAMPParams_str->hOPAMP_InvertingInput_GPIO_PORT,
    430                                   pDOPAMPParams_str->hOPAMP_InvertingInput_GPIO_PIN);
    431              }
    432              GPIO_InitStructure.GPIO_Pin = pDOPAMPParams_str->hOPAMP_Output_GPIO_PIN;
    433              GPIO_Init(pDOPAMPParams_str->hOPAMP_Output_GPIO_PORT, &GPIO_InitStructure);
    434              GPIO_PinLockConfig(pDOPAMPParams_str->hOPAMP_Output_GPIO_PORT,
    435                                 pDOPAMPParams_str->hOPAMP_Output_GPIO_PIN);
    436              
    437              OPAMP_InitStruct.OPAMP_InvertingInput = pDOPAMPParams_str->wOPAMP_InvertingInput;
    438              OPAMP_InitStruct.OPAMP_NonInvertingInput = pDOPAMPParams_str->wOPAMP_NonInvertingInput_PHA;
    439              OPAMP_Init(pDOPAMPParams_str->wOPAMP_Selection,&OPAMP_InitStruct);
    440              OPAMP_PGAConfig(pDOPAMPParams_str->wOPAMP_Selection,
    441                              pDOPAMPParams_str->wOPAMP_PGAGain,
    442                              pDOPAMPParams_str->OPAMP_PGAConnect);
    443              OPAMP_Cmd(pDOPAMPParams_str->wOPAMP_Selection,ENABLE);
    444              
    445              GPIO_InitStructure.GPIO_Pin = pDOPAMPParams_str->hOPAMP2_NonInvertingInput_PHB_GPIO_PIN;
    446              GPIO_Init(pDOPAMPParams_str->hOPAMP2_NonInvertingInput_PHB_GPIO_PORT, &GPIO_InitStructure);
    447              GPIO_PinLockConfig(pDOPAMPParams_str->hOPAMP2_NonInvertingInput_PHB_GPIO_PORT,
    448                                 pDOPAMPParams_str->hOPAMP2_NonInvertingInput_PHB_GPIO_PIN);
    449              GPIO_InitStructure.GPIO_Pin = pDOPAMPParams_str->hOPAMP2_NonInvertingInput_PHC_GPIO_PIN;
    450              GPIO_Init(pDOPAMPParams_str->hOPAMP2_NonInvertingInput_PHC_GPIO_PORT, &GPIO_InitStructure);
    451              GPIO_PinLockConfig(pDOPAMPParams_str->hOPAMP2_NonInvertingInput_PHC_GPIO_PORT,
    452                                 pDOPAMPParams_str->hOPAMP2_NonInvertingInput_PHC_GPIO_PIN);
    453              if (pDOPAMPParams_str->bOPAMP2_InvertingInput_MODE == EXT_MODE)
    454              {
    455                GPIO_InitStructure.GPIO_Pin = pDOPAMPParams_str->hOPAMP2_InvertingInput_GPIO_PIN;
    456                GPIO_Init(pDOPAMPParams_str->hOPAMP2_InvertingInput_GPIO_PORT, &GPIO_InitStructure);
    457                GPIO_PinLockConfig(pDOPAMPParams_str->hOPAMP2_InvertingInput_GPIO_PORT,
    458                                   pDOPAMPParams_str->hOPAMP2_InvertingInput_GPIO_PIN);
    459              }
    460              GPIO_InitStructure.GPIO_Pin = pDOPAMPParams_str->hOPAMP2_Output_GPIO_PIN;
    461              GPIO_Init(pDOPAMPParams_str->hOPAMP2_Output_GPIO_PORT, &GPIO_InitStructure);
    462              GPIO_PinLockConfig(pDOPAMPParams_str->hOPAMP2_Output_GPIO_PORT,
    463                                 pDOPAMPParams_str->hOPAMP2_Output_GPIO_PIN);
    464              
    465              OPAMP_InitStruct.OPAMP_InvertingInput = pDOPAMPParams_str->wOPAMP2_InvertingInput;
    466              OPAMP_InitStruct.OPAMP_NonInvertingInput = pDOPAMPParams_str->wOPAMP2_NonInvertingInput_PHB;
    467              OPAMP_Init(pDOPAMPParams_str->wOPAMP2_Selection,&OPAMP_InitStruct);
    468              OPAMP_PGAConfig(pDOPAMPParams_str->wOPAMP2_Selection,
    469                              pDOPAMPParams_str->wOPAMP_PGAGain,
    470                              pDOPAMPParams_str->OPAMP_PGAConnect);
    471              OPAMP_Cmd(pDOPAMPParams_str->wOPAMP2_Selection,ENABLE);
    472            }
    473            
    474            /* Over current protection phase A */
    475            if (pDOCPA_COMPParams_str)
    476            {
    477              COMP_InitTypeDef COMP_InitStruct;
    478              RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);
    479              
    480              /* NonInverting input*/
    481              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AN;
    482              GPIO_InitStructure.GPIO_Pin = pDOCPA_COMPParams_str->hNonInvertingInput_GPIO_PIN;
    483              GPIO_Init(pDOCPA_COMPParams_str->hNonInvertingInput_GPIO_PORT, &GPIO_InitStructure);
    484              GPIO_PinLockConfig(pDOCPA_COMPParams_str->hNonInvertingInput_GPIO_PORT,
    485                                 pDOCPA_COMPParams_str->hNonInvertingInput_GPIO_PIN);
    486              
    487              /* Inverting input*/
    488              if (pDOCPA_COMPParams_str->bInvertingInput_MODE == EXT_MODE)
    489              {
    490                GPIO_InitStructure.GPIO_Pin = pDOCPA_COMPParams_str->hInvertingInput_GPIO_PIN;
    491                GPIO_Init(pDOCPA_COMPParams_str->hInvertingInput_GPIO_PORT, &GPIO_InitStructure);
    492                GPIO_PinLockConfig(pDOCPA_COMPParams_str->hInvertingInput_GPIO_PORT,
    493                                   pDOCPA_COMPParams_str->hInvertingInput_GPIO_PIN);
    494              }
    495              else
    496              {
    497                if (pDOCPA_COMPParams_str->wInvertingInput == COMP_InvertingInput_DAC1OUT1)
    498                {
    499                  R3_4_F30X_SetAOReferenceVoltage(DAC_Channel_1, (uint16_t)(pDParams_str->hDAC_OCP_Threshold));
    500                }
    501                else if (pDOCPA_COMPParams_str->wInvertingInput == COMP_InvertingInput_DAC1OUT2)
    502                {
    503                  R3_4_F30X_SetAOReferenceVoltage(DAC_Channel_2, (uint16_t)(pDParams_str->hDAC_OCP_Threshold));
    504                }
    505                else
    506                {
    507                }
    508              }
    509              
    510              /* Wait to stabilize DAC voltage */
    511              {
    512                volatile uint16_t waittime = 0u;
    513                for(waittime=0u;waittime<1000u;waittime++)
    514                {
    515                }
    516              }
    517              
    518              /* Output */
    519              if (pDOCPA_COMPParams_str->bOutput_MODE == EXT_MODE)
    520              {
    521                GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
    522                GPIO_InitStructure.GPIO_Pin = pDOCPA_COMPParams_str->hOutput_GPIO_PIN;
    523                GPIO_Init(pDOCPA_COMPParams_str->hOutput_GPIO_PORT, &GPIO_InitStructure);
    524                GPIO_PinAFConfig(pDOCPA_COMPParams_str->hOutput_GPIO_PORT,
    525                                 F30X_GPIOPin2Source(pDOCPA_COMPParams_str->hOutput_GPIO_PIN),
    526                                 pDOCPA_COMPParams_str->bOutput_GPIO_AF);
    527                GPIO_PinLockConfig(pDOCPA_COMPParams_str->hOutput_GPIO_PORT,
    528                                   pDOCPA_COMPParams_str->hOutput_GPIO_PIN);
    529              }
    530              
    531              COMP_InitStruct.COMP_InvertingInput = pDOCPA_COMPParams_str->wInvertingInput;
    532              COMP_InitStruct.COMP_NonInvertingInput = pDOCPA_COMPParams_str->wNonInvertingInput;
    533              COMP_InitStruct.COMP_Output = pDOCPA_COMPParams_str->wOutput;
    534              COMP_InitStruct.COMP_OutputPol = pDOCPA_COMPParams_str->wOutputPol;
    535              COMP_InitStruct.COMP_BlankingSrce = COMP_BlankingSrce_None; 
    536              COMP_InitStruct.COMP_Hysteresis = COMP_Hysteresis_Low;
    537              COMP_InitStruct.COMP_Mode = pDOCPA_COMPParams_str->wMode;
    538              COMP_Init(pDOCPA_COMPParams_str->wSelection,&COMP_InitStruct);
    539              COMP_Cmd(pDOCPA_COMPParams_str->wSelection,ENABLE);
    540              COMP_LockConfig(pDOCPA_COMPParams_str->wSelection);
    541            }
    542            
    543            /* Over current protection phase B */
    544            if (pDOCPB_COMPParams_str)
    545            {
    546              COMP_InitTypeDef COMP_InitStruct;
    547              RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);
    548              
    549              /* NonInverting input*/
    550              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AN;
    551              GPIO_InitStructure.GPIO_Pin = pDOCPB_COMPParams_str->hNonInvertingInput_GPIO_PIN;
    552              GPIO_Init(pDOCPB_COMPParams_str->hNonInvertingInput_GPIO_PORT, &GPIO_InitStructure);
    553              GPIO_PinLockConfig(pDOCPB_COMPParams_str->hNonInvertingInput_GPIO_PORT,
    554                                 pDOCPB_COMPParams_str->hNonInvertingInput_GPIO_PIN);
    555              
    556              /* Inverting input*/
    557              if (pDOCPB_COMPParams_str->bInvertingInput_MODE == EXT_MODE)
    558              {
    559                GPIO_InitStructure.GPIO_Pin = pDOCPB_COMPParams_str->hInvertingInput_GPIO_PIN;
    560                GPIO_Init(pDOCPB_COMPParams_str->hInvertingInput_GPIO_PORT, &GPIO_InitStructure);
    561                GPIO_PinLockConfig(pDOCPB_COMPParams_str->hInvertingInput_GPIO_PORT,
    562                                   pDOCPB_COMPParams_str->hInvertingInput_GPIO_PIN);
    563              }
    564              
    565              /* Output */
    566              if (pDOCPB_COMPParams_str->bOutput_MODE == EXT_MODE)
    567              {
    568                GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
    569                GPIO_InitStructure.GPIO_Pin = pDOCPB_COMPParams_str->hOutput_GPIO_PIN;
    570                GPIO_Init(pDOCPB_COMPParams_str->hOutput_GPIO_PORT, &GPIO_InitStructure);
    571                GPIO_PinAFConfig(pDOCPB_COMPParams_str->hOutput_GPIO_PORT,
    572                                 F30X_GPIOPin2Source(pDOCPB_COMPParams_str->hOutput_GPIO_PIN),
    573                                 pDOCPB_COMPParams_str->bOutput_GPIO_AF);
    574                GPIO_PinLockConfig(pDOCPB_COMPParams_str->hOutput_GPIO_PORT,
    575                                   pDOCPB_COMPParams_str->hOutput_GPIO_PIN);
    576              }
    577              
    578              COMP_InitStruct.COMP_InvertingInput = pDOCPB_COMPParams_str->wInvertingInput;
    579              COMP_InitStruct.COMP_NonInvertingInput = pDOCPB_COMPParams_str->wNonInvertingInput;
    580              COMP_InitStruct.COMP_Output = pDOCPB_COMPParams_str->wOutput;
    581              COMP_InitStruct.COMP_OutputPol = pDOCPB_COMPParams_str->wOutputPol;
    582              COMP_InitStruct.COMP_BlankingSrce = COMP_BlankingSrce_None; 
    583              COMP_InitStruct.COMP_Hysteresis = COMP_Hysteresis_Low;
    584              COMP_InitStruct.COMP_Mode = pDOCPB_COMPParams_str->wMode;
    585              COMP_Init(pDOCPB_COMPParams_str->wSelection,&COMP_InitStruct);
    586              COMP_Cmd(pDOCPB_COMPParams_str->wSelection,ENABLE);
    587              COMP_LockConfig(pDOCPB_COMPParams_str->wSelection);
    588            }
    589            
    590            /* Over current protection phase C */
    591            if (pDOCPC_COMPParams_str)
    592            {
    593              COMP_InitTypeDef COMP_InitStruct;
    594              RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);
    595              
    596              /* NonInverting input*/
    597              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AN;
    598              GPIO_InitStructure.GPIO_Pin = pDOCPC_COMPParams_str->hNonInvertingInput_GPIO_PIN;
    599              GPIO_Init(pDOCPC_COMPParams_str->hNonInvertingInput_GPIO_PORT, &GPIO_InitStructure);
    600              GPIO_PinLockConfig(pDOCPC_COMPParams_str->hNonInvertingInput_GPIO_PORT,
    601                                 pDOCPC_COMPParams_str->hNonInvertingInput_GPIO_PIN);
    602              
    603              /* Inverting input*/
    604              if (pDOCPC_COMPParams_str->bInvertingInput_MODE == EXT_MODE)
    605              {
    606                GPIO_InitStructure.GPIO_Pin = pDOCPC_COMPParams_str->hInvertingInput_GPIO_PIN;
    607                GPIO_Init(pDOCPC_COMPParams_str->hInvertingInput_GPIO_PORT, &GPIO_InitStructure);
    608                GPIO_PinLockConfig(pDOCPC_COMPParams_str->hInvertingInput_GPIO_PORT,
    609                                   pDOCPC_COMPParams_str->hInvertingInput_GPIO_PIN);
    610              }
    611              
    612              /* Output */
    613              if (pDOCPC_COMPParams_str->bOutput_MODE == EXT_MODE)
    614              {
    615                GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
    616                GPIO_InitStructure.GPIO_Pin = pDOCPC_COMPParams_str->hOutput_GPIO_PIN;
    617                GPIO_Init(pDOCPC_COMPParams_str->hOutput_GPIO_PORT, &GPIO_InitStructure);
    618                GPIO_PinAFConfig(pDOCPC_COMPParams_str->hOutput_GPIO_PORT,
    619                                 F30X_GPIOPin2Source(pDOCPC_COMPParams_str->hOutput_GPIO_PIN),
    620                                 pDOCPC_COMPParams_str->bOutput_GPIO_AF);
    621                GPIO_PinLockConfig(pDOCPC_COMPParams_str->hOutput_GPIO_PORT,
    622                                   pDOCPC_COMPParams_str->hOutput_GPIO_PIN);
    623              }
    624              
    625              COMP_InitStruct.COMP_InvertingInput = pDOCPC_COMPParams_str->wInvertingInput;
    626              COMP_InitStruct.COMP_NonInvertingInput = pDOCPC_COMPParams_str->wNonInvertingInput;
    627              COMP_InitStruct.COMP_Output = pDOCPC_COMPParams_str->wOutput;
    628              COMP_InitStruct.COMP_OutputPol = pDOCPC_COMPParams_str->wOutputPol;
    629              COMP_InitStruct.COMP_BlankingSrce = COMP_BlankingSrce_None; 
    630              COMP_InitStruct.COMP_Hysteresis = COMP_Hysteresis_Low;
    631              COMP_InitStruct.COMP_Mode = pDOCPC_COMPParams_str->wMode;
    632              COMP_Init(pDOCPC_COMPParams_str->wSelection,&COMP_InitStruct);
    633              COMP_Cmd(pDOCPC_COMPParams_str->wSelection,ENABLE);
    634              COMP_LockConfig(pDOCPC_COMPParams_str->wSelection);
    635            }
    636            
    637            /* Over voltage protection */
    638            if (pDOVP_COMPParams_str)
    639            {
    640              COMP_InitTypeDef COMP_InitStruct;
    641              RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);
    642              
    643              /* NonInverting input*/
    644              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AN;
    645              GPIO_InitStructure.GPIO_Pin = pDOVP_COMPParams_str->hNonInvertingInput_GPIO_PIN;
    646              GPIO_Init(pDOVP_COMPParams_str->hNonInvertingInput_GPIO_PORT, &GPIO_InitStructure);
    647              GPIO_PinLockConfig(pDOVP_COMPParams_str->hNonInvertingInput_GPIO_PORT,
    648                                 pDOVP_COMPParams_str->hNonInvertingInput_GPIO_PIN);
    649              
    650              /* Inverting input*/
    651              if (pDOVP_COMPParams_str->bInvertingInput_MODE == EXT_MODE)
    652              {
    653                GPIO_InitStructure.GPIO_Pin = pDOVP_COMPParams_str->hInvertingInput_GPIO_PIN;
    654                GPIO_Init(pDOVP_COMPParams_str->hInvertingInput_GPIO_PORT, &GPIO_InitStructure);
    655                GPIO_PinLockConfig(pDOVP_COMPParams_str->hInvertingInput_GPIO_PORT,
    656                                   pDOVP_COMPParams_str->hInvertingInput_GPIO_PIN);
    657              }
    658              else
    659              {
    660                if (pDOVP_COMPParams_str->wInvertingInput == COMP_InvertingInput_DAC1OUT1)
    661                {
    662                  R3_4_F30X_SetAOReferenceVoltage(DAC_Channel_1, (uint16_t)(pDParams_str->hDAC_OVP_Threshold));
    663                }
    664                else if (pDOVP_COMPParams_str->wInvertingInput == COMP_InvertingInput_DAC1OUT2)
    665                {
    666                  R3_4_F30X_SetAOReferenceVoltage(DAC_Channel_2, (uint16_t)(pDParams_str->hDAC_OVP_Threshold));
    667                }
    668                else
    669                {
    670                }
    671              }
    672              
    673              /* Wait to stabilize DAC voltage */
    674              {
    675                volatile uint16_t waittime = 0u;
    676                for(waittime=0u;waittime<1000u;waittime++)
    677                {
    678                }
    679              }
    680              
    681              /* Output */
    682              if (pDOVP_COMPParams_str->bOutput_MODE == EXT_MODE)
    683              {
    684                GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
    685                GPIO_InitStructure.GPIO_Pin = pDOVP_COMPParams_str->hOutput_GPIO_PIN;
    686                GPIO_Init(pDOVP_COMPParams_str->hOutput_GPIO_PORT, &GPIO_InitStructure);
    687                GPIO_PinAFConfig(pDOVP_COMPParams_str->hOutput_GPIO_PORT,
    688                                 F30X_GPIOPin2Source(pDOVP_COMPParams_str->hOutput_GPIO_PIN),
    689                                 pDOVP_COMPParams_str->bOutput_GPIO_AF);
    690                GPIO_PinLockConfig(pDOVP_COMPParams_str->hOutput_GPIO_PORT,
    691                                   pDOVP_COMPParams_str->hOutput_GPIO_PIN);
    692              }
    693              
    694              COMP_InitStruct.COMP_InvertingInput = pDOVP_COMPParams_str->wInvertingInput;
    695              COMP_InitStruct.COMP_NonInvertingInput = pDOVP_COMPParams_str->wNonInvertingInput;
    696              COMP_InitStruct.COMP_Output = pDOVP_COMPParams_str->wOutput;
    697              COMP_InitStruct.COMP_OutputPol = pDOVP_COMPParams_str->wOutputPol;
    698              COMP_InitStruct.COMP_BlankingSrce = COMP_BlankingSrce_None; 
    699              COMP_InitStruct.COMP_Hysteresis = COMP_Hysteresis_Low;
    700              COMP_InitStruct.COMP_Mode = pDOVP_COMPParams_str->wMode;
    701              COMP_Init(pDOVP_COMPParams_str->wSelection,&COMP_InitStruct);
    702              COMP_Cmd(pDOVP_COMPParams_str->wSelection,ENABLE);
    703              COMP_LockConfig(pDOVP_COMPParams_str->wSelection);
    704            }
    705            
    706            /* Assignment of ADC resources for motor phases current measurements*/
    707            if (pDParams_str->bInstanceNbr == 1u)
    708            {
    709              ADCx_1 = ADC1;
    710              ADCx_2 = ADC2;
    711              NVIC_IRQChannel = (uint8_t) ADC1_2_IRQn;
    712            }
    713            else
    714            {
    715              ADCx_1 = ADC3;
    716              ADCx_2 = ADC4;
    717              NVIC_IRQChannel = (uint8_t) ADC3_IRQn;
    718            }
    719            pDVars_str->ADCx_1 = ADCx_1;
    720            pDVars_str->ADCx_2 = ADCx_2;
    721            
    722            /* For TIM1 the defualt vualue ADC_ExternalTrigInjecConvEvent_0 (TIM1_TRGO)
    723            is used.*/
    724            pDVars_str->ADC_ExternalTriggerInjected = ADC_ExternalTrigInjecConvEvent_0;
    725            if(TIMx == TIM8)
    726            {
    727              /* For TIM8 the ADC_ExternalTrigInjecConvEvent_9 (TIM8_TRGO) is used.*/
    728              pDVars_str->ADC_ExternalTriggerInjected = ADC_ExternalTrigInjecConvEvent_9;
    729            }
    730            
    731            /* Init ADC peripherals and related IRQ handler*/
    732            ADC_DeInit(ADCx_1);
    733            ADC_DeInit(ADCx_2);
    734            
    735            if (pDParams_str->bInstanceNbr == 1u)
    736            {
    737              if ((pDParams_str->regconvADCx != ADCx_1) &&
    738                  (pDParams_str->regconvADCx != ADCx_2))
    739              {
    740                if ((pDParams_str->regconvADCx == ADC1) ||
    741                    (pDParams_str->regconvADCx == ADC2))
    742                {
    743                  RCC_AHBPeriphClockCmd(RCC_AHBPeriph_ADC12, ENABLE);
    744                  
    745                  ADC_DeInit(pDParams_str->regconvADCx);
    746                  
    747                  /* Common init */
    748                  ADC_CommonStructInit(&ADC_CommonInitStructure);
    749                  ADC_CommonInitStructure.ADC_Mode=ADC_Mode_Independent;
    750                  ADC_CommonInitStructure.ADC_Clock=pDParams_str->wADC_Clock_Divider;
    751                  ADC_CommonInitStructure.ADC_DMAAccessMode=ADC_DMAAccessMode_Disabled;
    752                  ADC_CommonInitStructure.ADC_DMAMode=ADC_DMAMode_OneShot;
    753                  ADC_CommonInitStructure.ADC_TwoSamplingDelay= 0u;
    754                  ADC_CommonInit(ADC1, &ADC_CommonInitStructure);
    755                }
    756                else if ((pDParams_str->regconvADCx == ADC3) ||
    757                         (pDParams_str->regconvADCx == ADC4))
    758                {
    759                  RCC_AHBPeriphClockCmd(RCC_AHBPeriph_ADC34, ENABLE);
    760                  
    761                  ADC_DeInit(pDParams_str->regconvADCx);
    762                  
    763                  /* Common init */
    764                  ADC_CommonStructInit(&ADC_CommonInitStructure);
    765                  ADC_CommonInitStructure.ADC_Mode=ADC_Mode_Independent;
    766                  ADC_CommonInitStructure.ADC_Clock=pDParams_str->wADC_Clock_Divider;
    767                  ADC_CommonInitStructure.ADC_DMAAccessMode=ADC_DMAAccessMode_Disabled;
    768                  ADC_CommonInitStructure.ADC_DMAMode=ADC_DMAMode_OneShot;
    769                  ADC_CommonInitStructure.ADC_TwoSamplingDelay= 0u;
    770                  ADC_CommonInit(ADC3, &ADC_CommonInitStructure);
    771                }
    772                else
    773                {
    774                }
    775              }
    776            } 
    777            
    778            /* Common init */
    779            ADC_CommonStructInit(&ADC_CommonInitStructure);
    780            ADC_CommonInitStructure.ADC_Mode=ADC_Mode_Independent;
    781            ADC_CommonInitStructure.ADC_Clock=pDParams_str->wADC_Clock_Divider;
    782            ADC_CommonInitStructure.ADC_DMAAccessMode=ADC_DMAAccessMode_Disabled;
    783            ADC_CommonInitStructure.ADC_DMAMode=ADC_DMAMode_OneShot;
    784            ADC_CommonInitStructure.ADC_TwoSamplingDelay= 0u;
    785            ADC_CommonInit(ADCx_1, &ADC_CommonInitStructure);
    786            
    787            ADC_VoltageRegulatorCmd(ADCx_1, ENABLE);
    788            ADC_VoltageRegulatorCmd(ADCx_2, ENABLE);
    789            
    790            /* Wait for Regulator Startup time, once for both */
    791            {
    792              uint16_t waittime = 0u;
    793              for(waittime=0u;waittime<65000u;waittime++)
    794              {
    795              }
    796            }    
    797            
    798            ADC_SelectCalibrationMode(ADCx_1,ADC_CalibrationMode_Single);    
    799            ADC_StartCalibration(ADCx_1);
    800            while (ADC_GetCalibrationStatus(ADCx_1)== SET )
    801            {
    802            }
    803            
    804            ADC_SelectCalibrationMode(ADCx_2,ADC_CalibrationMode_Single);
    805            ADC_StartCalibration(ADCx_2);
    806            while (ADC_GetCalibrationStatus(ADCx_2)== SET )
    807            {
    808            }
    809            
    810            if (pDParams_str->bInstanceNbr == 1u)
    811            {
    812              if ((pDParams_str->regconvADCx != ADCx_1) &&
    813                  (pDParams_str->regconvADCx != ADCx_2))
    814              {
    815                {
    816                  ADC_VoltageRegulatorCmd(pDParams_str->regconvADCx, ENABLE);  
    817                  
    818                  /* Wait for Regulator Startup time, once for both */
    819                  {
    820                    uint16_t waittime = 0u;
    821                    for(waittime=0u;waittime<65000u;waittime++)
    822                    {
    823                    }
    824                  }    
    825                  
    826                  ADC_SelectCalibrationMode(pDParams_str->regconvADCx,ADC_CalibrationMode_Single);    
    827                  ADC_StartCalibration(pDParams_str->regconvADCx);
    828                  while (ADC_GetCalibrationStatus(pDParams_str->regconvADCx)== SET )
    829                  {
    830                  }       
    831                }
    832              }
    833            }
    834            
    835            /* Enable the ADC Interrupt */
    836            NVIC_InitStructure.NVIC_IRQChannel = NVIC_IRQChannel;
    837            NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 
    838              ADC_PRE_EMPTION_PRIORITY;
    839            NVIC_InitStructure.NVIC_IRQChannelSubPriority = ADC_SUB_PRIORITY;
    840            NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    841            NVIC_Init(&NVIC_InitStructure);    
    842            
    843            /* ADCx_1 and ADCx_2 registers configuration ---------------------------------*/
    844            
    845            /* Enable ADCx_1 and ADCx_2 */
    846            ADC_Cmd(ADCx_1, ENABLE);
    847            ADC_Cmd(ADCx_2, ENABLE);
    848            
    849            if (pDParams_str->bInstanceNbr == 1u)
    850            {
    851              if ((pDParams_str->regconvADCx != ADCx_1) &&
    852                  (pDParams_str->regconvADCx != ADCx_2))
    853              {
    854                ADC_Cmd(pDParams_str->regconvADCx, ENABLE);
    855                
    856                /* Configure the ADCx for reg conversions */
    857                ADC_StructInit(&ADC_InitStructure);
    858                ADC_InitStructure.ADC_ContinuousConvMode = ADC_ContinuousConvMode_Disable;
    859                ADC_InitStructure.ADC_Resolution = ADC_Resolution_12b; 
    860                ADC_InitStructure.ADC_ExternalTrigConvEvent = ADC_ExternalTrigConvEvent_0; /*dummy*/
    861                ADC_InitStructure.ADC_ExternalTrigEventEdge = ADC_ExternalTrigEventEdge_None;    
    862                ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Left;
    863                ADC_InitStructure.ADC_OverrunMode = ADC_OverrunMode_Disable;
    864                ADC_InitStructure.ADC_AutoInjMode = ADC_AutoInjec_Disable;
    865                ADC_InitStructure.ADC_NbrOfRegChannel = 1u;    
    866                ADC_Init(pDParams_str->regconvADCx, &ADC_InitStructure);
    867              }
    868            }
    869            
    870            /* Configure the ADC_x1&2 for reg conversions */
    871            ADC_StructInit(&ADC_InitStructure);
    872            ADC_InitStructure.ADC_ContinuousConvMode = ADC_ContinuousConvMode_Disable;
    873            ADC_InitStructure.ADC_Resolution = ADC_Resolution_12b; 
    874            ADC_InitStructure.ADC_ExternalTrigConvEvent = ADC_ExternalTrigConvEvent_0;
    875            ADC_InitStructure.ADC_ExternalTrigEventEdge = ADC_ExternalTrigEventEdge_None;    
    876            ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Left;
    877            ADC_InitStructure.ADC_OverrunMode = ADC_OverrunMode_Disable;
    878            ADC_InitStructure.ADC_AutoInjMode = ADC_AutoInjec_Disable;
    879            ADC_InitStructure.ADC_NbrOfRegChannel = 1u;
    880            
    881            ADC_Init(ADCx_1, &ADC_InitStructure);
    882            ADC_Init(ADCx_2, &ADC_InitStructure);
    883            
    884            pDVars_str->wADC_JSQR_phA = R3_4_F30X_ADC_InjectedChannelConfig(ADCx_1, pDParams_str->bIaChannel, 1u, pDParams_str->b_IaSamplingTime, 1u, ADC_ExternalTrigInjecEventEdge_RisingEdge, pDVars_str->ADC_ExternalTriggerInjected);
    885            pDVars_str->wADC_JSQR_phB = R3_4_F30X_ADC_InjectedChannelConfig(ADCx_2, pDParams_str->bIbChannel, 1u, pDParams_str->b_IbSamplingTime, 1u, ADC_ExternalTrigInjecEventEdge_RisingEdge, pDVars_str->ADC_ExternalTriggerInjected);
    886            pDVars_str->wADC_JSQR_phC = R3_4_F30X_ADC_InjectedChannelConfig(ADCx_2, pDParams_str->bIcChannel, 1u, pDParams_str->b_IcSamplingTime, 1u, ADC_ExternalTrigInjecEventEdge_RisingEdge, pDVars_str->ADC_ExternalTriggerInjected);
    887            R3_4_F30X_ADC_InjectedChannelConfig(ADCx_2, pDParams_str->bIaChannel, 1u, pDParams_str->b_IaSamplingTime, 1u, ADC_ExternalTrigInjecEventEdge_RisingEdge, pDVars_str->ADC_ExternalTriggerInjected);
    888            R3_4_F30X_ADC_InjectedChannelConfig(ADCx_1, pDParams_str->bIbChannel, 1u, pDParams_str->b_IbSamplingTime, 1u, ADC_ExternalTrigInjecEventEdge_RisingEdge, pDVars_str->ADC_ExternalTriggerInjected);
    889            R3_4_F30X_ADC_InjectedChannelConfig(ADCx_1, pDParams_str->bIcChannel, 1u, pDParams_str->b_IcSamplingTime, 1u, ADC_ExternalTrigInjecEventEdge_RisingEdge, pDVars_str->ADC_ExternalTriggerInjected);
    890            
    891            if (pDParams_str->pOPAMPParams)
    892            {
    893              pDVars_str->wADC1_JSQR = pDVars_str->wADC_JSQR_phA;
    894              pDVars_str->wADC2_JSQR = pDVars_str->wADC_JSQR_phB;
    895            }
    896            
    897            ADC_SelectQueueOfContextMode(ADCx_1,ENABLE);
    898            ADC_SelectQueueOfContextMode(ADCx_2,ENABLE);
    899            
    900            ADCx_1->JSQR = R3_4_F30X_ADC_InjectedChannelConfig(ADCx_1, 0u, 1u, 0u, 1u, ADC_ExternalTrigInjecEventEdge_RisingEdge, pDVars_str->ADC_ExternalTriggerInjected);
    901            ADCx_2->JSQR = R3_4_F30X_ADC_InjectedChannelConfig(ADCx_2, 0u, 1u, 0u, 1u, ADC_ExternalTrigInjecEventEdge_RisingEdge, pDVars_str->ADC_ExternalTriggerInjected);
    902            ADCx_1->CR |= ADC_CR_JADSTART;
    903            ADCx_2->CR |= ADC_CR_JADSTART;
    904            
    905            TIM_OC4PreloadConfig(TIMx, TIM_OCPreload_Disable);
    906            TIMx->CCR4 = 0xFFFFu;
    907            TIMx->CCR4 = 0x0u;
    908            TIM_OC4PreloadConfig(TIMx, TIM_OCPreload_Enable);
    909            
    910            while (ADC_GetFlagStatus(ADCx_1,ADC_FLAG_JEOS)==RESET)
    911            {
    912            }
    913            while (ADC_GetFlagStatus(ADCx_2,ADC_FLAG_JEOS)==RESET)
    914            {
    915            }
    916            
    917            /* ADCx_1 Injected conversions end interrupt enabling */
    918            ADC_ClearFlag(ADCx_1, ADC_FLAG_JEOS);
    919            ADC_ClearFlag(ADCx_2, ADC_FLAG_JEOS);
    920            ADC_ITConfig(ADCx_1, ADC_IT_JEOS, ENABLE);
    921            
    922            if(pDParams_str->TIMx==TIM1)
    923            {
    924              /* Enable the TIM1 BRK interrupt */
    925              NVIC_InitStructure.NVIC_IRQChannel = (uint8_t) TIM1_BRK_TIM15_IRQn;
    926              NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = TIMx_BRK_PRE_EMPTION_PRIORITY;
    927              NVIC_InitStructure.NVIC_IRQChannelSubPriority = TIMx_BRK_SUB_PRIORITY;
    928              NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    929              NVIC_Init(&NVIC_InitStructure);
    930            }
    931            else
    932            {
    933              /* Enable the TIM8 BRK interrupt */
    934              NVIC_InitStructure.NVIC_IRQChannel = (uint8_t) TIM8_BRK_IRQn;
    935              NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = TIMx_BRK_PRE_EMPTION_PRIORITY;
    936              NVIC_InitStructure.NVIC_IRQChannelSubPriority = TIMx_BRK_SUB_PRIORITY;
    937              NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    938              NVIC_Init(&NVIC_InitStructure);
    939            }
    940            
    941            /* Clear the flags */
    942            pDVars_str->OverVoltageFlag = FALSE;
    943            pDVars_str->OverCurrentFlag = FALSE;
    944          }
    945          
    946          /**
    947          * @brief  It initializes TIMx peripheral for PWM generation
    948          * @param 'TIMx': Timer to be initialized
    949          * @param 'this': related object of class CR3_4_F30X_PWMC
    950          * @retval none
    951          */
    952          static void R3_4_F30X_TIMxInit(TIM_TypeDef* TIMx, CPWMC this)
    953          {
    954            TIM_TimeBaseInitTypeDef TIMx_TimeBaseStructure;
    955            TIM_OCInitTypeDef TIMx_OCInitStructure;
    956            TIM_BDTRInitTypeDef_MC TIMx_BDTRInitStructure;
    957            pDVars_t pDVars_str = &DCLASS_VARS;  
    958            pDParams_t pDParams_str =DCLASS_PARAMS; 
    959            
    960            /* TIMx Peripheral Configuration -------------------------------------------*/
    961            /* TIMx Registers reset */
    962            TIM_DeInit(TIMx);
    963            TIM_TimeBaseStructInit(&TIMx_TimeBaseStructure);
    964            /* Time Base configuration */
    965            TIMx_TimeBaseStructure.TIM_Prescaler = (uint16_t)(pDParams_str->bTim_Clock_Divider) - 1u;
    966            TIMx_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_CenterAligned1;
    967            TIMx_TimeBaseStructure.TIM_Period = pDVars_str->Half_PWMPeriod;
    968            TIMx_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV2;
    969            TIMx_TimeBaseStructure.TIM_RepetitionCounter = pDParams_str->
    970                                                                      bRepetitionCounter;
    971            TIM_TimeBaseInit(TIMx, &TIMx_TimeBaseStructure);
    972            
    973            /* Channel 1, 2,3 and 4 Configuration in PWM mode */
    974            TIM_OCStructInit(&TIMx_OCInitStructure);  
    975            TIMx_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1; 
    976            TIMx_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable; 
    977            TIMx_OCInitStructure.TIM_Pulse = (uint32_t)(pDVars_str->Half_PWMPeriod)/2u; /* dummy value */
    978            
    979            /* Channel 1 */
    980            TIMx_OCInitStructure.TIM_OCPolarity = pDParams_str->hCh1Polarity;      
    981            TIMx_OCInitStructure.TIM_OCIdleState = pDParams_str->hCh1IdleState;    
    982            if ((pDParams_str-> LowSideOutputs)== LS_PWM_TIMER)
    983            {
    984              TIMx_OCInitStructure.TIM_OutputNState = TIM_OutputNState_Enable; 
    985              TIMx_OCInitStructure.TIM_OCNPolarity = pDParams_str->hCh1NPolarity; 
    986              TIMx_OCInitStructure.TIM_OCNIdleState = pDParams_str->hCh1NIdleState;     
    987            }    
    988            else
    989            {
    990              TIMx_OCInitStructure.TIM_OutputNState = TIM_OutputNState_Disable;
    991            }    
    992            TIM_OC1Init(TIMx, &TIMx_OCInitStructure); 
    993            
    994            
    995            /* Channel 2 */
    996            TIMx_OCInitStructure.TIM_OCPolarity = pDParams_str->hCh2Polarity;      
    997            TIMx_OCInitStructure.TIM_OCIdleState = pDParams_str->hCh2IdleState;    
    998            if ((pDParams_str-> LowSideOutputs)== LS_PWM_TIMER)
    999            {
   1000            TIMx_OCInitStructure.TIM_OCNPolarity = pDParams_str->hCh2NPolarity; 
   1001            TIMx_OCInitStructure.TIM_OCNIdleState = pDParams_str->hCh2NIdleState;         
   1002            }
   1003            TIM_OC2Init(TIMx, &TIMx_OCInitStructure); 
   1004            
   1005            
   1006            /* Channel 3 */
   1007            TIMx_OCInitStructure.TIM_OCPolarity = pDParams_str->hCh3Polarity;      
   1008            TIMx_OCInitStructure.TIM_OCIdleState = pDParams_str->hCh3IdleState;    
   1009            if ((pDParams_str-> LowSideOutputs)== LS_PWM_TIMER)
   1010            {
   1011            TIMx_OCInitStructure.TIM_OCNPolarity = pDParams_str->hCh3NPolarity; 
   1012            TIMx_OCInitStructure.TIM_OCNIdleState = pDParams_str->hCh3NIdleState;         
   1013            }
   1014            TIM_OC3Init(TIMx, &TIMx_OCInitStructure);   
   1015            
   1016              /* Channel 4 */
   1017            TIMx_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM2;
   1018            TIMx_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;      
   1019            TIMx_OCInitStructure.TIM_OCIdleState = TIM_OCIdleState_Reset; 
   1020            TIMx_OCInitStructure.TIM_Pulse = 0xFFFFu;
   1021            TIM_OC4Init(TIMx, &TIMx_OCInitStructure); 
   1022            
   1023            /* Enables the TIMx Preload on CC1 Register */
   1024            TIM_OC1PreloadConfig(TIMx, TIM_OCPreload_Enable);
   1025            /* Enables the TIMx Preload on CC2 Register */
   1026            TIM_OC2PreloadConfig(TIMx, TIM_OCPreload_Enable);
   1027            /* Enables the TIMx Preload on CC3 Register */
   1028            TIM_OC3PreloadConfig(TIMx, TIM_OCPreload_Enable);
   1029            /* Enables the TIMx Preload on CC4 Register */
   1030            TIM_OC4PreloadConfig(TIMx, TIM_OCPreload_Enable); 
   1031            
   1032            /* Set channel 4 as TRGO */
   1033            TIM_SelectOutputTrigger(TIMx,TIM_TRGOSource_OC4Ref);
   1034            
   1035            /* Set update as TRGO2 */
   1036            TIM_SelectOutputTrigger2(TIMx, TIM_TRGO2Source_OC3Ref);
   1037            
   1038            TIM_BDTRStructInit_MC(&TIMx_BDTRInitStructure);
   1039            /* Dead Time */
   1040            TIMx_BDTRInitStructure.TIM_OSSRState = TIM_OSSRState_Enable;
   1041            TIMx_BDTRInitStructure.TIM_OSSIState = TIM_OSSIState_Disable;
   1042            TIMx_BDTRInitStructure.TIM_LOCKLevel = TIM_LOCKLevel_1; 
   1043            TIMx_BDTRInitStructure.TIM_DeadTime = (pDParams_str->hDeadTime)/2u;
   1044            
   1045            /* Always enable BKIN for safety fature */
   1046            TIMx_BDTRInitStructure.TIM_Break = TIM_Break1_Enable;
   1047            if ((pDParams_str->bBKINMode) == EXT_MODE)
   1048            {
   1049              /* Set from the power stage */
   1050              TIMx_BDTRInitStructure.TIM_BreakPolarity = pDParams_str->hBKINPolarity;
   1051            }
   1052            else
   1053            {
   1054              /* Internal - always active high */
   1055              TIMx_BDTRInitStructure.TIM_BreakPolarity = TIM_Break1Polarity_High;
   1056            }
   1057            TIMx_BDTRInitStructure.TIM_Break1Filter = pDParams_str->bBKINFilter;
   1058            TIMx_BDTRInitStructure.TIM_AutomaticOutput = TIM_AutomaticOutput_Disable;
   1059            TIM_ClearITPendingBit(TIMx, TIM_IT_Break);
   1060            TIM_ITConfig(TIMx, TIM_IT_Break, ENABLE);
   1061            
   1062            if ((pDParams_str->bBKIN2Mode) != NONE)
   1063            {
   1064              TIMx_BDTRInitStructure.TIM_Break2 = TIM_Break2_Enable;
   1065              if ((pDParams_str->bBKIN2Mode) == EXT_MODE)
   1066              {
   1067                /* Set from the power stage */
   1068                TIMx_BDTRInitStructure.TIM_Break2Polarity = pDParams_str->hBKIN2Polarity;
   1069              }
   1070              else
   1071              {
   1072                /* Internal - always active high */
   1073                TIMx_BDTRInitStructure.TIM_Break2Polarity = TIM_Break2Polarity_High;
   1074              }
   1075              TIMx_BDTRInitStructure.TIM_Break2Filter = pDParams_str->bBKIN2Filter;
   1076              TIMx_BDTRInitStructure.TIM_AutomaticOutput = TIM_AutomaticOutput_Disable;
   1077              TIMx->SR = ~(((uint32_t)(TIM_IT_Break)<<1)); /* Clear BKIN2F. Not possible with stdlib V1.0.1 */
   1078              TIM_ITConfig(TIMx, TIM_IT_Break, ENABLE);
   1079            }
   1080            TIM_BDTRConfig_MC(TIMx, &TIMx_BDTRInitStructure);
   1081           
   1082            TIM_SelectInputTrigger(TIMx,TIM_TS_ITR1);
   1083            TIM_SelectSlaveMode(TIMx,TIM_SlaveMode_Trigger);
   1084          
   1085            /* Prepare timer for synchronization */
   1086            TIM_GenerateEvent(TIMx,TIM_EventSource_Update);
   1087                
   1088            if (pDParams_str->bFreqRatio == 2u) 
   1089            {
   1090              if (pDParams_str->bIsHigherFreqTim == HIGHER_FREQ)
   1091              {
   1092                if (pDParams_str->bRepetitionCounter == 3u)
   1093                {
   1094                  /* Set TIMx repetition counter to 1 */
   1095                  TIMx->RCR =0x01u; 
   1096                  TIM_GenerateEvent(TIMx, TIM_EventSource_Update);
   1097                  /* Repetition counter will be set to 3 at next Update */
   1098                  TIMx->RCR =0x03u; 
   1099                }
   1100              }
   1101              
   1102              TIM_SetCounter(TIMx, (uint32_t)(pDVars_str->Half_PWMPeriod)-1u);
   1103            }
   1104            else /* bFreqRatio equal to 1 or 3 */
   1105            {
   1106              if (pDParams_str->bInstanceNbr == 1u)
   1107              {
   1108                if(pDParams_str->bRepetitionCounter == 1u)
   1109                {
   1110                  TIM_SetCounter(TIMx, (uint32_t)(pDVars_str->Half_PWMPeriod)-1u);
   1111                }  
   1112                else if (pDParams_str->bRepetitionCounter == 3u)
   1113                {
   1114                  /* Set TIMx repetition counter to 1 */
   1115                  TIMx->RCR =0x01u;
   1116                  TIM_GenerateEvent(TIMx, TIM_EventSource_Update);
   1117                  /* Repetition counter will be set to 3 at next Update */
   1118                  TIMx->RCR =0x03u; 
   1119                } 
   1120              }
   1121            }
   1122          }
   1123          
   1124          /**
   1125          * @brief  It perform the start of all the timers required by the control. 
   1126                    It utilizes TIM2 as temporary timer to achieve synchronization between 
   1127                    PWM signals.
   1128                    When this function is called, TIM1 and/or TIM8 must be in frozen state
   1129                    with CNT, ARR, REP RATE and trigger correctly set (these setting are 
   1130                    usually performed in the Init method accordingly with the configuration)
   1131          * @param  none
   1132          * @retval none
   1133          */
   1134           void R3_4_F3XX_StartTimers(void)
   1135          {
   1136           TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;   
   1137            
   1138            /* Temporary Enable TIM2 clock */
   1139            RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);
   1140            TIM_DeInit(TIM2);
   1141            TIM_TimeBaseStructInit(&TIM_TimeBaseStructure);
   1142            /* Time Base configuration */
   1143            TIM_TimeBaseStructure.TIM_Prescaler = 0x0u;
   1144            TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
   1145            TIM_TimeBaseStructure.TIM_Period = 1u; /* dummy */ 
   1146            TIM_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV1;
   1147            TIM_TimeBaseInit(TIM2, &TIM_TimeBaseStructure);
   1148            
   1149            TIM_SelectOutputTrigger(TIM2, TIM_TRGOSource_Update);  
   1150               
   1151            TIM_Cmd(TIM2, ENABLE);
   1152            
   1153            TIM_DeInit(TIM2);
   1154            RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, DISABLE); 
   1155          }
   1156          
   1157          
   1158          /**
   1159          * @brief  It stores into 'this' object variables the voltage present on Ia and 
   1160          *         Ib current feedback analog channels when no current is flowin into the
   1161          *         motor
   1162          * @param  this: related object of class CR3_4_F30X_PWMC
   1163          * @retval none
   1164          */
   1165          static void R3_4_F30X_CurrentReadingCalibration(CPWMC this)
   1166          {
   1167            Vars_t *pBaseVars = &((_CPWMC) this)->Vars_str;
   1168            pDVars_t pDVars_str = &DCLASS_VARS;
   1169            pDParams_t pDParams_str =  DCLASS_PARAMS;
   1170            pR3_4_F30XOPAMPParams_t pDOPAMPParams_str = pDParams_str->pOPAMPParams;
   1171            TIM_TypeDef*  TIMx = pDParams_str->TIMx;
   1172            uint16_t hCalibrationPeriodCounter;
   1173            uint16_t hMaxPeriodsNumber;
   1174            
   1175            pDVars_str-> wPhaseAOffset = 0u;
   1176            pDVars_str-> wPhaseBOffset = 0u; 
   1177            pDVars_str-> wPhaseCOffset = 0u; 
   1178            
   1179            pDVars_str->bIndex=0u;
   1180            
   1181            /* It forces inactive level on TIMx CHy and CHyN */
   1182            TIMx->CCER &= (~TIMxCCER_MASK_CH123);
   1183             
   1184            /* Offset calibration for A & B phases */
   1185            /* Change function to be executed in ADCx_ISR */ 
   1186            ((_CPWMC) this)->Methods_str.pPWMC_GetPhaseCurrents = &R3_4_F30X_HFCurrentsCalibrationAB;
   1187            ((_CPWMC) this)->Methods_str.pPWMC_SetADCSampPointSect1 = &R3_4_F30X_SetADCSampPointCalibration;
   1188            ((_CPWMC) this)->Methods_str.pPWMC_SetADCSampPointSect2 = &R3_4_F30X_SetADCSampPointCalibration;
   1189            ((_CPWMC) this)->Methods_str.pPWMC_SetADCSampPointSect3 = &R3_4_F30X_SetADCSampPointCalibration;
   1190            ((_CPWMC) this)->Methods_str.pPWMC_SetADCSampPointSect4 = &R3_4_F30X_SetADCSampPointCalibration;
   1191            ((_CPWMC) this)->Methods_str.pPWMC_SetADCSampPointSect5 = &R3_4_F30X_SetADCSampPointCalibration;
   1192            ((_CPWMC) this)->Methods_str.pPWMC_SetADCSampPointSect6 = &R3_4_F30X_SetADCSampPointCalibration;
   1193            
   1194            if (pDOPAMPParams_str)
   1195            {
   1196              OPAMP_InitTypeDef OPAMP_InitStruct1;
   1197              OPAMP_InitTypeDef OPAMP_InitStruct2;
   1198              OPAMP_InitStruct1.OPAMP_InvertingInput = pDOPAMPParams_str->wOPAMP_InvertingInput;
   1199              OPAMP_InitStruct1.OPAMP_NonInvertingInput = pDOPAMPParams_str->wOPAMP_NonInvertingInput_PHA;
   1200              pDVars_str->wOAMP1CR = R3_4_F30X_OPAMP_Init(pDOPAMPParams_str->wOPAMP_Selection,&OPAMP_InitStruct1);
   1201              OPAMP_InitStruct2.OPAMP_InvertingInput = pDOPAMPParams_str->wOPAMP2_InvertingInput;
   1202              OPAMP_InitStruct2.OPAMP_NonInvertingInput = pDOPAMPParams_str->wOPAMP2_NonInvertingInput_PHB;
   1203              pDVars_str->wOAMP2CR = R3_4_F30X_OPAMP_Init(pDOPAMPParams_str->wOPAMP2_Selection,&OPAMP_InitStruct2);
   1204              
   1205            }
   1206            else
   1207            {
   1208              pDVars_str->wADC1_JSQR = pDVars_str->wADC_JSQR_phA;
   1209              pDVars_str->wADC2_JSQR = pDVars_str->wADC_JSQR_phB;
   1210            }
   1211            
   1212            R3_4_F30X_SwitchOnPWM(this);
   1213            
   1214            /* Wait for NB_CONVERSIONS to be executed */
   1215            hMaxPeriodsNumber=(NB_CONVERSIONS+1u)*(((uint16_t)(pDParams_str->bRepetitionCounter)+1u)>>1);
   1216            TIMx->SR = (uint16_t)~TIM_FLAG_CC1;
   1217            hCalibrationPeriodCounter = 0u;
   1218            while (pDVars_str->bIndex < NB_CONVERSIONS)
   1219            {
   1220              if (TIMx->SR & TIM_FLAG_CC1)
   1221              {
   1222                TIMx->SR = (uint16_t)~TIM_FLAG_CC1;
   1223                hCalibrationPeriodCounter++;
   1224                if (hCalibrationPeriodCounter >= hMaxPeriodsNumber)
   1225                {
   1226                  if (pDVars_str->bIndex < NB_CONVERSIONS)
   1227                  {
   1228                    pBaseVars->SWerror = 1u;
   1229                    break;
   1230                  }
   1231                }
   1232              }
   1233            }
   1234            
   1235            R3_4_F30X_SwitchOffPWM(this);
   1236          
   1237            /* Offset calibration for C phase */
   1238            /* Reset bIndex */
   1239            pDVars_str->bIndex=0u;
   1240          
   1241            /* Change function to be executed in ADCx_ISR */ 
   1242            ((_CPWMC) this)->Methods_str.pPWMC_GetPhaseCurrents = &R3_4_F30X_HFCurrentsCalibrationC;
   1243          
   1244            if (pDOPAMPParams_str)
   1245            {
   1246              OPAMP_InitTypeDef OPAMP_InitStruct3;
   1247          		OPAMP_InitStruct3.OPAMP_InvertingInput = pDOPAMPParams_str->wOPAMP2_InvertingInput;
   1248              OPAMP_InitStruct3.OPAMP_NonInvertingInput = pDOPAMPParams_str->wOPAMP2_NonInvertingInput_PHC;
   1249              pDVars_str->wOAMP2CR = R3_4_F30X_OPAMP_Init(pDOPAMPParams_str->wOPAMP2_Selection,&OPAMP_InitStruct3);
   1250            }
   1251            else
   1252            {
   1253              pDVars_str->wADC1_JSQR = pDVars_str->wADC_JSQR_phC;
   1254            }
   1255            
   1256            R3_4_F30X_SwitchOnPWM(this);
   1257            
   1258            /* Wait for NB_CONVERSIONS to be executed */
   1259            TIMx->SR = (uint16_t)~TIM_FLAG_CC1;
   1260            hCalibrationPeriodCounter = 0u;
   1261            while (pDVars_str->bIndex < NB_CONVERSIONS)
   1262            {
   1263              if (TIMx->SR & TIM_FLAG_CC1)
   1264              {
   1265                TIMx->SR = (uint16_t)~TIM_FLAG_CC1;
   1266                hCalibrationPeriodCounter++;
   1267                if (hCalibrationPeriodCounter >= hMaxPeriodsNumber)
   1268                {
   1269                  if (pDVars_str->bIndex < NB_CONVERSIONS)
   1270                  {
   1271                    pBaseVars->SWerror = 1u;
   1272                    break;
   1273                  }
   1274                }
   1275              }
   1276            }
   1277            
   1278            R3_4_F30X_SwitchOffPWM(this);
   1279            
   1280            pDVars_str->wPhaseAOffset >>=4; 
   1281            pDVars_str->wPhaseBOffset >>=4; 
   1282            pDVars_str->wPhaseCOffset >>=4; 
   1283          
   1284            /* Change back function to be executed in ADCx_ISR */ 
   1285            ((_CPWMC) this)->Methods_str.pPWMC_GetPhaseCurrents = &R3_4_F30X_GetPhaseCurrents;
   1286            ((_CPWMC) this)->Methods_str.pPWMC_SetADCSampPointSect1 = &R3_4_F30X_SetADCSampPointSect1;
   1287            ((_CPWMC) this)->Methods_str.pPWMC_SetADCSampPointSect2 = &R3_4_F30X_SetADCSampPointSect2;
   1288            ((_CPWMC) this)->Methods_str.pPWMC_SetADCSampPointSect3 = &R3_4_F30X_SetADCSampPointSect3;
   1289            ((_CPWMC) this)->Methods_str.pPWMC_SetADCSampPointSect4 = &R3_4_F30X_SetADCSampPointSect4;
   1290            ((_CPWMC) this)->Methods_str.pPWMC_SetADCSampPointSect5 = &R3_4_F30X_SetADCSampPointSect5;
   1291            ((_CPWMC) this)->Methods_str.pPWMC_SetADCSampPointSect6 = &R3_4_F30X_SetADCSampPointSect6;
   1292          
   1293            /* It over write TIMx CCRy wrongly written by FOC during calibration so as to 
   1294               force 50% duty cycle on the three inverer legs */
   1295            /* Disable TIMx preload */  
   1296            TIMx->CCMR1 &= 0xF7F7u;
   1297            TIMx->CCMR2 &= 0xF7F7u;
   1298            TIMx->CCR1 = pDVars_str->Half_PWMPeriod;
   1299            TIMx->CCR2 = pDVars_str->Half_PWMPeriod;
   1300            TIMx->CCR3 = pDVars_str->Half_PWMPeriod;
   1301            
   1302            /* Enable TIMx preload */
   1303            TIMx->CCMR1 |= 0x0808u;
   1304            TIMx->CCMR2 |= 0x0808u;
   1305            
   1306            /* It re-enable drive of TIMx CHy and CHyN by TIMx CHyRef*/
   1307            TIMx->CCER |= TIMxCCER_MASK_CH123;
   1308            
   1309            pDVars_str->BrakeActionLock = FALSE;
   1310          }
   1311          
   1312          #if defined (CCMRAM)
   1313          #if defined (__ICCARM__)
   1314          #pragma location = ".ccmram"
   1315          #elif defined (__CC_ARM)
   1316          __attribute__((section ("ccmram")))
   1317          #endif
   1318          #endif
   1319          /**
   1320          * @brief  It computes and return latest converted motor phase currents motor
   1321          * @param  this: related object of class CR3_4_F30X_PWMC
   1322          * @retval Ia and Ib current in Curr_Components format
   1323          */
   1324          static void R3_4_F30X_GetPhaseCurrents(CPWMC this,Curr_Components* pStator_Currents)
   1325          {
   1326            uint8_t bSector;
   1327            int32_t wAux;
   1328            uint16_t hReg1,hReg2;
   1329            pDVars_t pDVars_str = &(((_DCR3_4_F30X_PWMC)(((_CPWMC) this)->DerivedClass))->DVars_str);
   1330            
   1331            /* Clear the flag to indicate the start of FOC algorithm*/
   1332            DCLASS_PARAMS->TIMx->SR = (uint16_t)(~TIM_FLAG_Update);
   1333            
   1334            hReg1 = (uint16_t)(pDVars_str->ADCx_1->JDR1); 
   1335            hReg2 = (uint16_t)(pDVars_str->ADCx_2->JDR1);
   1336            
   1337            bSector = (uint8_t)(((_CPWMC)this)->Vars_str.hSector);
   1338          
   1339            switch (bSector)
   1340            {
   1341            case SECTOR_4:
   1342            case SECTOR_5: 
   1343              /* Current on Phase C is not accessible     */
   1344              /* Ia = PhaseAOffset - ADC converted value) */
   1345              wAux = (int32_t)(pDVars_str->wPhaseAOffset)-(int32_t)(hReg1);
   1346              
   1347              /* Saturation of Ia */
   1348              if (wAux < S16_MIN)
   1349              {
   1350                pStator_Currents->qI_Component1= S16_MIN;
   1351              }  
   1352              else  if (wAux > S16_MAX)
   1353              { 
   1354                pStator_Currents->qI_Component1= S16_MAX;
   1355              }
   1356              else
   1357              {
   1358                pStator_Currents->qI_Component1= (int16_t)wAux;
   1359              }
   1360              
   1361              /* Ib = PhaseBOffset - ADC converted value) */
   1362              wAux = (int32_t)(pDVars_str->wPhaseBOffset)-(int32_t)(hReg2);
   1363              
   1364              /* Saturation of Ib */
   1365              if (wAux < S16_MIN)
   1366              {
   1367                pStator_Currents->qI_Component2= S16_MIN;
   1368              }  
   1369              else  if (wAux > S16_MAX)
   1370              { 
   1371                pStator_Currents->qI_Component2= S16_MAX;
   1372              }
   1373              else
   1374              {
   1375                pStator_Currents->qI_Component2= (int16_t)wAux;
   1376              }
   1377              break;
   1378              
   1379            case SECTOR_6:
   1380            case SECTOR_1:  
   1381              /* Current on Phase A is not accessible     */
   1382              /* Ib = PhaseBOffset - ADC converted value) */
   1383              wAux = (int32_t)(pDVars_str->wPhaseBOffset)-(int32_t)(hReg1);
   1384              
   1385              /* Saturation of Ib */
   1386              if (wAux < S16_MIN)
   1387              {
   1388                pStator_Currents->qI_Component2= S16_MIN;
   1389              }  
   1390              else  if (wAux > S16_MAX)
   1391              { 
   1392                pStator_Currents->qI_Component2= S16_MAX;
   1393              }
   1394              else
   1395              {
   1396                pStator_Currents->qI_Component2= (int16_t)wAux;
   1397              }
   1398              
   1399              /* Ia = -Ic -Ib */
   1400              wAux = (int32_t)(hReg2) - (int32_t)(pDVars_str->wPhaseCOffset); /* -Ic */
   1401              wAux -= (int32_t)pStator_Currents->qI_Component2;               /* Ia  */
   1402          
   1403              /* Saturation of Ia */
   1404              if (wAux> S16_MAX)
   1405              {
   1406                pStator_Currents->qI_Component1 = S16_MAX;
   1407              }
   1408              else  if (wAux <S16_MIN)
   1409              {
   1410                pStator_Currents->qI_Component1 = S16_MIN;
   1411              }
   1412              else
   1413              {  
   1414                pStator_Currents->qI_Component1 = (int16_t)wAux;
   1415              }
   1416              break;
   1417              
   1418            case SECTOR_2:
   1419            case SECTOR_3:
   1420              /* Current on Phase B is not accessible     */
   1421              /* Ia = PhaseAOffset - ADC converted value) */
   1422              wAux = (int32_t)(pDVars_str->wPhaseAOffset)-(int32_t)(hReg1);
   1423              
   1424              /* Saturation of Ia */
   1425              if (wAux < S16_MIN)
   1426              {
   1427                pStator_Currents->qI_Component1= S16_MIN;
   1428              }  
   1429              else  if (wAux > S16_MAX)
   1430              { 
   1431                pStator_Currents->qI_Component1= S16_MAX;
   1432              }
   1433              else
   1434              {
   1435                pStator_Currents->qI_Component1= (int16_t)wAux;
   1436              }
   1437              
   1438              /* Ib = -Ic -Ia */
   1439              wAux = (int32_t)(hReg2) - (int32_t)(pDVars_str->wPhaseCOffset); /* -Ic */
   1440              wAux -= (int32_t)pStator_Currents->qI_Component1;               /* Ib */
   1441          
   1442              /* Saturation of Ib */
   1443              if (wAux> S16_MAX)
   1444              {
   1445                pStator_Currents->qI_Component2=S16_MAX;
   1446              }
   1447              else  if (wAux <S16_MIN)
   1448              {  
   1449                pStator_Currents->qI_Component2 = S16_MIN;
   1450              }
   1451              else  
   1452              {
   1453                pStator_Currents->qI_Component2 = (int16_t)wAux;
   1454              }                     
   1455              break;
   1456              
   1457            default:
   1458              break;
   1459            }   
   1460          }
   1461          
   1462          /**
   1463          * @brief  Implementaion of PWMC_GetPhaseCurrents to be performed during 
   1464          *         calibration. It sum up injected conversion data into wPhaseAOffset and
   1465          *         wPhaseBOffset to compute the offset introduced in the current feedback
   1466          *         network. It is requied to proper configure ADC inputs before to enable
   1467          *         the offset computation.
   1468          * @param  this: related object of class CPWMC
   1469          * @retval It always returns {0,0} in Curr_Components format
   1470          */
   1471          static void R3_4_F30X_HFCurrentsCalibrationAB(CPWMC this,Curr_Components* pStator_Currents)
   1472          {  
   1473            /* Derived class members container */
   1474            pDVars_t pDVars_str = &DCLASS_VARS; 
   1475            
   1476            /* Clear the flag to indicate the start of FOC algorithm*/
   1477            DCLASS_PARAMS->TIMx->SR = (uint16_t)(~TIM_FLAG_Update);
   1478            
   1479            if (pDVars_str->bIndex < NB_CONVERSIONS)
   1480            {
   1481              pDVars_str-> wPhaseAOffset += pDVars_str->ADCx_1->JDR1;
   1482              pDVars_str-> wPhaseBOffset += pDVars_str->ADCx_2->JDR1;
   1483              pDVars_str->bIndex++;
   1484            }
   1485          }
   1486          
   1487          /**
   1488          * @brief  Implementaion of PWMC_GetPhaseCurrents to be performed during 
   1489          *         calibration. It sum up injected conversion data into wPhaseCOffset
   1490          *         to compute the offset introduced in the current feedback
   1491          *         network. It is requied to proper configure ADC input before to enable
   1492          *         the offset computation.
   1493          * @param  this: related object of class CPWMC
   1494          * @retval It always returns {0,0} in Curr_Components format
   1495          */
   1496          static void R3_4_F30X_HFCurrentsCalibrationC(CPWMC this,Curr_Components* pStator_Currents)
   1497          {
   1498            /* Derived class members container */
   1499            pDVars_t pDVars_str = &DCLASS_VARS;
   1500            
   1501            /* Clear the flag to indicate the start of FOC algorithm*/
   1502            DCLASS_PARAMS->TIMx->SR = (uint16_t)(~TIM_FLAG_Update);
   1503            
   1504            if (pDVars_str->bIndex < NB_CONVERSIONS)
   1505            {
   1506              pDVars_str-> wPhaseCOffset += pDVars_str->ADCx_2->JDR1; 
   1507              pDVars_str->bIndex++;
   1508            }
   1509          }
   1510          
   1511          /**
   1512            * @brief  It turns on low sides switches. This function is intended to be 
   1513            *         used for charging boot capacitors of driving section. It has to be 
   1514            *         called each motor start-up when using high voltage drivers
   1515            * @param  this: related object of class CR3_4_F30X_PWMC
   1516            * @retval none
   1517            */
   1518          static void R3_4_F30X_TurnOnLowSides(CPWMC this)
   1519          {
   1520            pDParams_t pLocalDParams = DCLASS_PARAMS;
   1521            TIM_TypeDef*  TIMx = DCLASS_PARAMS->TIMx;  
   1522            
   1523            /* Clear Update Flag */
   1524            TIM_ClearFlag(TIMx, (uint16_t)(TIM_FLAG_Update));
   1525            
   1526            /*Turn on the three low side switches */
   1527            TIMx->CCR1 = 0u;
   1528            TIMx->CCR2 = 0u;
   1529            TIMx->CCR3 = 0u;
   1530            
   1531            /* Wait until next update */
   1532            while (TIM_GetFlagStatus(TIMx,TIM_FLAG_Update)==RESET)
   1533            {}
   1534            
   1535            /* Main PWM Output Enable */
   1536            TIMx->BDTR |= TIM_BDTR_MOE;
   1537            
   1538            if ((pLocalDParams->LowSideOutputs)== ES_GPIO)
   1539            {
   1540              GPIO_WriteBit(pLocalDParams->hCh1NPort, pLocalDParams->hCh1NPin, Bit_SET);
   1541              GPIO_WriteBit(pLocalDParams->hCh2NPort, pLocalDParams->hCh2NPin, Bit_SET);
   1542              GPIO_WriteBit(pLocalDParams->hCh3NPort, pLocalDParams->hCh3NPin, Bit_SET);
   1543            }
   1544            return; 
   1545          }
   1546          
   1547          
   1548          /**
   1549          * @brief  It enables PWM generation on the proper Timer peripheral acting on MOE
   1550          *         bit
   1551          * @param  this: related object of class CR3_4_F30X_PWMC
   1552          * @retval none
   1553          */
   1554          static void R3_4_F30X_SwitchOnPWM(CPWMC this)
   1555          {  
   1556            TIM_TypeDef* TIMx = DCLASS_PARAMS->TIMx;
   1557            pDParams_t pDParams_str = DCLASS_PARAMS;
   1558            pVars_t pVars_str = &CLASS_VARS;
   1559            pDVars_t pDVars_str = &DCLASS_VARS;
   1560            pR3_4_F30XOPAMPParams_t pDOPAMPParams_str = pDParams_str->pOPAMPParams;
   1561            
   1562            /* wait for a new PWM period */
   1563            TIM_ClearFlag(TIMx, (uint16_t)(TIM_FLAG_Update));
   1564            while (TIM_GetFlagStatus(TIMx,TIM_FLAG_Update) == RESET)
   1565            {}
   1566            /* Clear Update Flag */
   1567            TIM_ClearFlag(TIMx, (uint16_t)(TIM_FLAG_Update));
   1568            
   1569            /* Set all duty to 50% */
   1570            if (pVars_str->RLDetectionMode == TRUE)
   1571            {
   1572              TIMx->CCR1 = 1u;
   1573              pDVars_str->ADCx_2->JSQR = pDVars_str->wADC2_JSQR;
   1574            }
   1575            else
   1576            {
   1577              TIMx->CCR1 = (uint32_t)(pDVars_str->Half_PWMPeriod) >> 1;
   1578            }
   1579            TIMx->CCR2 = (uint32_t)(pDVars_str->Half_PWMPeriod) >> 1;
   1580            TIMx->CCR3 = (uint32_t)(pDVars_str->Half_PWMPeriod) >> 1;
   1581            TIMx->CCR4 = (uint32_t)(pDVars_str->Half_PWMPeriod) - 5u;
   1582            
   1583            while (TIM_GetFlagStatus(TIMx,TIM_FLAG_Update) == RESET)
   1584            {}
   1585            
   1586            /* Main PWM Output Enable */
   1587            TIMx->BDTR |= TIM_OSSIState_Enable; 
   1588            TIMx->BDTR |= TIM_BDTR_MOE;
   1589            
   1590            if ((pDParams_str->LowSideOutputs)== ES_GPIO)
   1591            {
   1592              if ((TIMx->CCER & TIMxCCER_MASK_CH123) != 0u)
   1593              {
   1594                GPIO_WriteBit(pDParams_str->hCh1NPort, pDParams_str->hCh1NPin, Bit_SET);
   1595                GPIO_WriteBit(pDParams_str->hCh2NPort, pDParams_str->hCh2NPin, Bit_SET);
   1596                GPIO_WriteBit(pDParams_str->hCh3NPort, pDParams_str->hCh3NPin, Bit_SET);
   1597              }
   1598              else
   1599              {
   1600                /* It is executed during calibration phase the EN signal shall stay off */
   1601                GPIO_WriteBit(pDParams_str->hCh1NPort, pDParams_str->hCh1NPin, Bit_RESET);
   1602                GPIO_WriteBit(pDParams_str->hCh2NPort, pDParams_str->hCh2NPin, Bit_RESET);
   1603                GPIO_WriteBit(pDParams_str->hCh3NPort, pDParams_str->hCh3NPin, Bit_RESET);
   1604              }
   1605            }
   1606            
   1607            /* Switch Context */
   1608            if (pDOPAMPParams_str)
   1609            {
   1610              uint32_t wAux = OPAMP_BASE + pDOPAMPParams_str->wOPAMP_Selection;
   1611              *(__IO uint32_t *) (wAux) = pDVars_str->wOAMP1CR;
   1612              wAux = OPAMP_BASE + pDOPAMPParams_str->wOPAMP2_Selection;
   1613              *(__IO uint32_t *) (wAux) = pDVars_str->wOAMP2CR;
   1614            }
   1615            pDVars_str->ADCx_1->JSQR = pDVars_str->wADC1_JSQR;
   1616            if (pVars_str->RLDetectionMode == FALSE)
   1617            {
   1618              pDVars_str->ADCx_2->JSQR = pDVars_str->wADC2_JSQR;
   1619            }
   1620            return; 
   1621          }
   1622          
   1623          
   1624          /**
   1625          * @brief  It disables PWM generation on the proper Timer peripheral acting on 
   1626          *         MOE bit
   1627          * @param  this: related object of class CR3_4_F30X_PWMC
   1628          * @retval none
   1629          */
   1630          static void R3_4_F30X_SwitchOffPWM(CPWMC this)
   1631          { 
   1632            pDParams_t pDParams_str = DCLASS_PARAMS;
   1633            pDVars_t pDVars_str = &DCLASS_VARS;
   1634            TIM_TypeDef* TIMx = pDParams_str->TIMx;
   1635            
   1636            /* Main PWM Output Disable */
   1637            if (DCLASS_VARS.BrakeActionLock == TRUE)
   1638            {
   1639            }
   1640            else
   1641            {
   1642              TIMx->BDTR &= ~((uint32_t)(TIM_OSSIState_Enable));
   1643              
   1644              if ((pDParams_str->LowSideOutputs)== ES_GPIO)
   1645              {
   1646                GPIO_WriteBit(pDParams_str->hCh1NPort, pDParams_str->hCh1NPin, Bit_RESET);
   1647                GPIO_WriteBit(pDParams_str->hCh2NPort, pDParams_str->hCh2NPin, Bit_RESET);
   1648                GPIO_WriteBit(pDParams_str->hCh3NPort, pDParams_str->hCh3NPin, Bit_RESET);
   1649              }
   1650            }
   1651            TIMx->BDTR &= (uint32_t)~TIM_BDTR_MOE;
   1652            
   1653            /* ADC_ITConfig(ADCx, ADC_IT_JEOS, DISABLE);*/
   1654            pDVars_str->ADCx_1->IER &= (~(uint32_t)ADC_IT_JEOS);
   1655            
   1656            /* Flushing JSQR queue of context by setting JADSTP = 1 (JQM)=1 */
   1657            pDVars_str->ADCx_1->CR |= ADC_CR_JADSTP;
   1658            pDVars_str->ADCx_2->CR |= ADC_CR_JADSTP;
   1659            
   1660            pDVars_str->ADCx_1->JSQR = R3_4_F30X_ADC_InjectedChannelConfig(pDVars_str->ADCx_1, 0u, 1u, 0u, 1u, ADC_ExternalTrigInjecEventEdge_RisingEdge, pDVars_str->ADC_ExternalTriggerInjected);
   1661            pDVars_str->ADCx_2->JSQR = R3_4_F30X_ADC_InjectedChannelConfig(pDVars_str->ADCx_2, 0u, 1u, 0u, 1u, ADC_ExternalTrigInjecEventEdge_RisingEdge, pDVars_str->ADC_ExternalTriggerInjected);
   1662            pDVars_str->ADCx_1->CR |= ADC_CR_JADSTART;
   1663            pDVars_str->ADCx_2->CR |= ADC_CR_JADSTART;
   1664            
   1665            TIM_OC4PreloadConfig(TIMx, TIM_OCPreload_Disable);
   1666            /* Set CC4 as PWM mode 2 (default) */
   1667            TIMx->CCMR2 &= CCMR2_CH4_DISABLE;
   1668            TIMx->CCMR2 |= CCMR2_CH4_PWM2;
   1669            TIMx->CCR4 = 0xFFFFu;
   1670            TIMx->CCR4 = 0x0u;
   1671            TIM_OC4PreloadConfig(TIMx, TIM_OCPreload_Enable);
   1672            
   1673            while (ADC_GetFlagStatus(pDVars_str->ADCx_1,ADC_FLAG_JEOS)==RESET)
   1674            {}
   1675            while (ADC_GetFlagStatus(pDVars_str->ADCx_2,ADC_FLAG_JEOS)==RESET)
   1676            {}
   1677            
   1678            /* ADCx_1 Injected conversions end interrupt enabling */
   1679            ADC_ClearFlag(pDVars_str->ADCx_1, ADC_FLAG_JEOS);
   1680            ADC_ClearFlag(pDVars_str->ADCx_2, ADC_FLAG_JEOS);
   1681            ADC_ITConfig(pDVars_str->ADCx_1, ADC_IT_JEOS, ENABLE);  
   1682            return; 
   1683          }
   1684          
   1685          #if defined (CCMRAM)
   1686          #if defined (__ICCARM__)
   1687          #pragma location = ".ccmram"
   1688          #elif defined (__CC_ARM)
   1689          __attribute__((section ("ccmram")))
   1690          #endif
   1691          #endif
   1692          /**
   1693          * @brief  It stores into 'this' object variables the voltage present on Ia and 
   1694          *         Ib current feedback analog channels when no current is flowin into the
   1695          *         motor
   1696          * @param  this: related object of class CR3_4_F30X_PWMC
   1697          * @retval none
   1698          */
   1699          static uint16_t R3_4_F30X_WriteTIMRegisters(CPWMC this)
   1700          {
   1701            uint16_t hAux,hCCR4Aux;
   1702            TIM_TypeDef*  TIMx = DCLASS_PARAMS->TIMx;
   1703            pDVars_t pDVars_str = &DCLASS_VARS;
   1704            pDParams_t pDParams_str = DCLASS_PARAMS;
   1705            pR3_4_F30XOPAMPParams_t pDOPAMPParams_str = pDParams_str->pOPAMPParams;
   1706              
   1707            TIMx->CCR1 = ((_CPWMC) this)->Vars_str.hCntPhA;
   1708            TIMx->CCR2 = ((_CPWMC) this)->Vars_str.hCntPhB;
   1709            TIMx->CCR3 = ((_CPWMC) this)->Vars_str.hCntPhC;
   1710            hCCR4Aux = (uint16_t)(TIMx->CCR4);
   1711            TIM_OC4PreloadConfig(TIMx, TIM_OCPreload_Disable);
   1712            TIMx->CCR4 = 0xFFFFu;
   1713            TIM_OC4PreloadConfig(TIMx, TIM_OCPreload_Enable);
   1714            TIMx->CCR4 = hCCR4Aux;
   1715            
   1716            /* Switch Context */
   1717            if (pDOPAMPParams_str)
   1718            {
   1719              uint32_t wAux = OPAMP_BASE + pDOPAMPParams_str->wOPAMP_Selection;
   1720              *(__IO uint32_t *) (wAux) = pDVars_str->wOAMP1CR;
   1721              wAux = OPAMP_BASE + pDOPAMPParams_str->wOPAMP2_Selection;
   1722              *(__IO uint32_t *) (wAux) = pDVars_str->wOAMP2CR;
   1723            }
   1724            pDVars_str->ADCx_1->JSQR = pDVars_str->wADC1_JSQR;
   1725            pDVars_str->ADCx_2->JSQR = pDVars_str->wADC2_JSQR;
   1726              
   1727            /* Limit for update event */
   1728            /* Check the status flag. If an update event has occurred before to set new
   1729            values of regs the FOC rate is too high */
   1730            if (TIMx->SR & TIM_FLAG_Update)
   1731            {
   1732              hAux = MC_FOC_DURATION;
   1733            }
   1734            else
   1735            {
   1736              hAux = MC_NO_ERROR;
   1737            }
   1738            if (((_CPWMC) this)->Vars_str.SWerror == 1u)
   1739            {
   1740              hAux = MC_FOC_DURATION;
   1741              ((_CPWMC) this)->Vars_str.SWerror = 0u;
   1742            }
   1743            return hAux;
   1744          }
   1745          
   1746          #if defined (CCMRAM)
   1747          #if defined (__ICCARM__)
   1748          #pragma location = ".ccmram"
   1749          #elif defined (__CC_ARM)
   1750          __attribute__((section ("ccmram")))
   1751          #endif
   1752          #endif
   1753          /**
   1754          * @brief  Configure the ADC for the current sampling during calibration.
   1755          *         It means set the sampling point via TIMx_Ch4 value and polarity
   1756          *         ADC sequence length and channels.
   1757          *         And call the WriteTIMRegisters method.
   1758          * @param  this related object of class CPWMC
   1759          * @retval none
   1760          */
   1761          static uint16_t R3_4_F30X_SetADCSampPointCalibration(CPWMC this)
   1762          {
   1763            pDParams_t pDParams_str =  ((_DCR3_4_F30X_PWMC)(((_CPWMC) this)->DerivedClass))->pDParams_str;
   1764            DVars_t *pLocalVars_Str = &DCLASS_VARS;
   1765            TIM_TypeDef*  TIMx = pDParams_str->TIMx;
   1766            
   1767            /* Set CC4 as PWM mode 2 (default) */
   1768            TIMx->CCMR2 &= CCMR2_CH4_DISABLE;
   1769            TIMx->CCMR2 |= CCMR2_CH4_PWM2;
   1770            
   1771            TIMx->CCR4 = (uint32_t)(PWM_PERIOD) - 1u;
   1772            
   1773            return R3_4_F30X_WriteTIMRegisters(this);
   1774          }
   1775          
   1776          #if defined (CCMRAM)
   1777          #if defined (__ICCARM__)
   1778          #pragma location = ".ccmram"
   1779          #elif defined (__CC_ARM)
   1780          __attribute__((section ("ccmram")))
   1781          #endif
   1782          #endif
   1783          /**
   1784          * @brief  Configure the ADC for the current sampling related to sector 1.
   1785          *         It means set the sampling point via TIMx_Ch4 value and polarity
   1786          *         ADC sequence length and channels.
   1787          *         And call the WriteTIMRegisters method.
   1788          * @param  this related object of class CPWMC
   1789          * @retval none
   1790          */
   1791          static uint16_t R3_4_F30X_SetADCSampPointSect1(CPWMC this)
   1792          {
   1793            uint16_t hCntSmp, hDeltaDuty;
   1794            Vars_t *pBaseVars = &((_CPWMC) this)->Vars_str;
   1795            pDParams_t pDParams_str =  ((_DCR3_4_F30X_PWMC)(((_CPWMC) this)->DerivedClass))->pDParams_str;
   1796            DVars_t *pLocalVars_Str = &DCLASS_VARS;
   1797            TIM_TypeDef*  TIMx = pDParams_str->TIMx;
   1798            pR3_4_F30XOPAMPParams_t pDOPAMPParams_str = pDParams_str->pOPAMPParams;
   1799          
   1800            /* Set CC4 as PWM mode 2 (default) */
   1801            TIMx->CCMR2 &= CCMR2_CH4_DISABLE;
   1802            TIMx->CCMR2 |= CCMR2_CH4_PWM2;
   1803            
   1804            /* Check if sampling AB in the middle of PWM is possible */
   1805            if (((uint16_t)(PWM_PERIOD-pBaseVars->hCntPhA) > pDParams_str->hTafter) &&
   1806                ((uint16_t)(PWM_PERIOD-pBaseVars->hCntPhB) > pDParams_str->hTafter))
   1807            {
   1808              TIMx->CCR4 = (uint32_t)(PWM_PERIOD) - 1u;
   1809              ((_CPWMC)this)->Vars_str.hSector = SECTOR_4; /* Dummy just for the GetPhaseCurrent */
   1810              if (pDOPAMPParams_str)
   1811              {
   1812                OPAMP_InitTypeDef OPAMP_InitStruct1;
   1813                OPAMP_InitTypeDef OPAMP_InitStruct2;
   1814                OPAMP_InitStruct1.OPAMP_InvertingInput = pDOPAMPParams_str->wOPAMP_InvertingInput;
   1815                OPAMP_InitStruct1.OPAMP_NonInvertingInput = pDOPAMPParams_str->wOPAMP_NonInvertingInput_PHA;
   1816                pLocalVars_Str->wOAMP1CR = R3_4_F30X_OPAMP_Init(pDOPAMPParams_str->wOPAMP_Selection,&OPAMP_InitStruct1);
   1817                OPAMP_InitStruct2.OPAMP_InvertingInput = pDOPAMPParams_str->wOPAMP2_InvertingInput;
   1818                OPAMP_InitStruct2.OPAMP_NonInvertingInput = pDOPAMPParams_str->wOPAMP2_NonInvertingInput_PHB;
   1819                pLocalVars_Str->wOAMP2CR = R3_4_F30X_OPAMP_Init(pDOPAMPParams_str->wOPAMP2_Selection,&OPAMP_InitStruct2);
   1820              }
   1821              else
   1822              {
   1823                pLocalVars_Str->wADC1_JSQR = pLocalVars_Str->wADC_JSQR_phA;
   1824                pLocalVars_Str->wADC2_JSQR = pLocalVars_Str->wADC_JSQR_phB;
   1825              }
   1826            }
   1827            else
   1828            {
   1829              if ((u16)(PWM_PERIOD-pBaseVars->hCntPhA) > pDParams_str->hTafter)
   1830              {
   1831                hCntSmp = PWM_PERIOD - 1u;
   1832              }
   1833              else
   1834              {
   1835                hDeltaDuty = (u16)(pBaseVars->hCntPhA - pBaseVars->hCntPhB);
   1836                
   1837                /* Definition of crossing point */
   1838                if (hDeltaDuty > (u16)(PWM_PERIOD-pBaseVars->hCntPhA)*2u)
   1839                {
   1840                  hCntSmp = pBaseVars->hCntPhA - pDParams_str->hTbefore;
   1841                }
   1842                else
   1843                {
   1844                  hCntSmp = pBaseVars->hCntPhA + pDParams_str->hTafter;
   1845                  
   1846                  if (hCntSmp >= PWM_PERIOD)
   1847                  { 
   1848                    /* Set CC4 as PWM mode 1 */
   1849                    TIMx->CCMR2 &= CCMR2_CH4_DISABLE;
   1850                    TIMx->CCMR2 |= CCMR2_CH4_PWM1;
   1851                    
   1852                    hCntSmp = (2u * PWM_PERIOD) - hCntSmp - 1u;
   1853                  }
   1854                }
   1855              }
   1856              
   1857              if (pDOPAMPParams_str)
   1858              {
   1859                OPAMP_InitTypeDef OPAMP_InitStruct1;
   1860                OPAMP_InitTypeDef OPAMP_InitStruct2;
   1861                OPAMP_InitStruct1.OPAMP_InvertingInput = pDOPAMPParams_str->wOPAMP_InvertingInput;
   1862                OPAMP_InitStruct1.OPAMP_NonInvertingInput = pDOPAMPParams_str->wOPAMP_NonInvertingInput_PHB;
   1863                pLocalVars_Str->wOAMP1CR = R3_4_F30X_OPAMP_Init(pDOPAMPParams_str->wOPAMP_Selection,&OPAMP_InitStruct1);
   1864                OPAMP_InitStruct2.OPAMP_InvertingInput = pDOPAMPParams_str->wOPAMP2_InvertingInput;
   1865                OPAMP_InitStruct2.OPAMP_NonInvertingInput = pDOPAMPParams_str->wOPAMP2_NonInvertingInput_PHC;
   1866                pLocalVars_Str->wOAMP2CR = R3_4_F30X_OPAMP_Init(pDOPAMPParams_str->wOPAMP2_Selection,&OPAMP_InitStruct2);
   1867              }
   1868              else
   1869              {
   1870                pLocalVars_Str->wADC1_JSQR = pLocalVars_Str->wADC_JSQR_phB;
   1871                pLocalVars_Str->wADC2_JSQR = pLocalVars_Str->wADC_JSQR_phC;
   1872              }
   1873              
   1874              /* Set TIMx_CH4 value */
   1875              TIMx->CCR4 = hCntSmp;
   1876            }
   1877            return R3_4_F30X_WriteTIMRegisters(this);
   1878          }
   1879          
   1880          #if defined (CCMRAM)
   1881          #if defined (__ICCARM__)
   1882          #pragma location = ".ccmram"
   1883          #elif defined (__CC_ARM)
   1884          __attribute__((section ("ccmram")))
   1885          #endif
   1886          #endif
   1887          /**
   1888          * @brief  Configure the ADC for the current sampling related to sector 2.
   1889          *         It means set the sampling point via TIMx_Ch4 value and polarity
   1890          *         ADC sequence length and channels.
   1891          *         And call the WriteTIMRegisters method.
   1892          * @param  this related object of class CPWMC
   1893          * @retval none
   1894          */
   1895          static uint16_t R3_4_F30X_SetADCSampPointSect2(CPWMC this)
   1896          {
   1897            uint16_t hCntSmp, hDeltaDuty;
   1898            Vars_t *pBaseVars = &((_CPWMC) this)->Vars_str;
   1899            pDParams_t pDParams_str =  ((_DCR3_4_F30X_PWMC)(((_CPWMC) this)->DerivedClass))->pDParams_str;
   1900            DVars_t *pLocalVars_Str = &DCLASS_VARS;
   1901            TIM_TypeDef*  TIMx = pDParams_str->TIMx;
   1902            pR3_4_F30XOPAMPParams_t pDOPAMPParams_str = pDParams_str->pOPAMPParams;
   1903          
   1904            /* Set CC4 as PWM mode 2 (default) */
   1905            TIMx->CCMR2 &= CCMR2_CH4_DISABLE;
   1906            TIMx->CCMR2 |= CCMR2_CH4_PWM2;
   1907            
   1908            /* Check if sampling AB in the middle of PWM is possible */
   1909            if (((uint16_t)(PWM_PERIOD-pBaseVars->hCntPhA) > pDParams_str->hTafter) &&
   1910                ((uint16_t)(PWM_PERIOD-pBaseVars->hCntPhB) > pDParams_str->hTafter))
   1911            {
   1912              TIMx->CCR4 = (uint32_t)(PWM_PERIOD) - 1u;
   1913              ((_CPWMC)this)->Vars_str.hSector = SECTOR_4; /* Dummy just for the GetPhaseCurrent */
   1914              if (pDOPAMPParams_str)
   1915              {
   1916                OPAMP_InitTypeDef OPAMP_InitStruct1;
   1917                OPAMP_InitTypeDef OPAMP_InitStruct2;
   1918                OPAMP_InitStruct1.OPAMP_InvertingInput = pDOPAMPParams_str->wOPAMP_InvertingInput;
   1919                OPAMP_InitStruct1.OPAMP_NonInvertingInput = pDOPAMPParams_str->wOPAMP_NonInvertingInput_PHA;
   1920                pLocalVars_Str->wOAMP1CR = R3_4_F30X_OPAMP_Init(pDOPAMPParams_str->wOPAMP_Selection,&OPAMP_InitStruct1);
   1921                OPAMP_InitStruct2.OPAMP_InvertingInput = pDOPAMPParams_str->wOPAMP2_InvertingInput;
   1922                OPAMP_InitStruct2.OPAMP_NonInvertingInput = pDOPAMPParams_str->wOPAMP2_NonInvertingInput_PHB;
   1923                pLocalVars_Str->wOAMP2CR = R3_4_F30X_OPAMP_Init(pDOPAMPParams_str->wOPAMP2_Selection,&OPAMP_InitStruct2);
   1924              }
   1925              else
   1926              {
   1927                pLocalVars_Str->wADC1_JSQR = pLocalVars_Str->wADC_JSQR_phA;
   1928                pLocalVars_Str->wADC2_JSQR = pLocalVars_Str->wADC_JSQR_phB;
   1929              }
   1930            }
   1931            else
   1932            {
   1933              if ((u16)(PWM_PERIOD-pBaseVars->hCntPhB) > pDParams_str->hTafter)
   1934              {
   1935                hCntSmp = PWM_PERIOD - 1u;
   1936              }
   1937              else
   1938              {
   1939                hDeltaDuty = (u16)(pBaseVars->hCntPhB - pBaseVars->hCntPhA);
   1940                
   1941                /* Definition of crossing point */
   1942                if (hDeltaDuty > (u16)(PWM_PERIOD-pBaseVars->hCntPhB)*2u)
   1943                {
   1944                  hCntSmp = pBaseVars->hCntPhB - pDParams_str->hTbefore;
   1945                }
   1946                else
   1947                {
   1948                  hCntSmp = pBaseVars->hCntPhB + pDParams_str->hTafter;
   1949                  
   1950                  if (hCntSmp >= PWM_PERIOD)
   1951                  {
   1952                    /* Set CC4 as PWM mode 1 */
   1953                    TIMx->CCMR2 &= CCMR2_CH4_DISABLE;
   1954                    TIMx->CCMR2 |= CCMR2_CH4_PWM1;
   1955                    
   1956                    hCntSmp = (2u * PWM_PERIOD) - hCntSmp - 1u;
   1957                  }
   1958                }
   1959              }
   1960              
   1961              if (pDOPAMPParams_str)
   1962              {
   1963                OPAMP_InitTypeDef OPAMP_InitStruct1;
   1964                OPAMP_InitTypeDef OPAMP_InitStruct2;
   1965                OPAMP_InitStruct1.OPAMP_InvertingInput = pDOPAMPParams_str->wOPAMP_InvertingInput;
   1966                OPAMP_InitStruct1.OPAMP_NonInvertingInput = pDOPAMPParams_str->wOPAMP_NonInvertingInput_PHA;
   1967                pLocalVars_Str->wOAMP1CR = R3_4_F30X_OPAMP_Init(pDOPAMPParams_str->wOPAMP_Selection,&OPAMP_InitStruct1);
   1968                OPAMP_InitStruct2.OPAMP_InvertingInput = pDOPAMPParams_str->wOPAMP2_InvertingInput;
   1969                OPAMP_InitStruct2.OPAMP_NonInvertingInput = pDOPAMPParams_str->wOPAMP2_NonInvertingInput_PHC;
   1970                pLocalVars_Str->wOAMP2CR = R3_4_F30X_OPAMP_Init(pDOPAMPParams_str->wOPAMP2_Selection,&OPAMP_InitStruct2);
   1971              }
   1972              else
   1973              {
   1974                pLocalVars_Str->wADC1_JSQR = pLocalVars_Str->wADC_JSQR_phA;
   1975                pLocalVars_Str->wADC2_JSQR = pLocalVars_Str->wADC_JSQR_phC;
   1976              }
   1977              
   1978              /* Set TIMx_CH4 value */
   1979              TIMx->CCR4 = hCntSmp; 
   1980            }
   1981            return R3_4_F30X_WriteTIMRegisters(this);
   1982          }
   1983          
   1984          #if defined (CCMRAM)
   1985          #if defined (__ICCARM__)
   1986          #pragma location = ".ccmram"
   1987          #elif defined (__CC_ARM)
   1988          __attribute__((section ("ccmram")))
   1989          #endif
   1990          #endif
   1991          /**
   1992          * @brief  Configure the ADC for the current sampling related to sector 3.
   1993          *         It means set the sampling point via TIMx_Ch4 value and polarity
   1994          *         ADC sequence length and channels.
   1995          *         And call the WriteTIMRegisters method.
   1996          * @param  this related object of class CPWMC
   1997          * @retval none
   1998          */
   1999          static uint16_t R3_4_F30X_SetADCSampPointSect3(CPWMC this)
   2000          {
   2001            uint16_t hCntSmp, hDeltaDuty;
   2002            Vars_t *pBaseVars = &((_CPWMC) this)->Vars_str;
   2003            pDParams_t pDParams_str =  ((_DCR3_4_F30X_PWMC)(((_CPWMC) this)->DerivedClass))->pDParams_str;
   2004            DVars_t *pLocalVars_Str = &DCLASS_VARS;
   2005            TIM_TypeDef*  TIMx = pDParams_str->TIMx;
   2006            pR3_4_F30XOPAMPParams_t pDOPAMPParams_str = pDParams_str->pOPAMPParams;
   2007          
   2008            /* Set CC4 as PWM mode 2 (default) */
   2009            TIMx->CCMR2 &= CCMR2_CH4_DISABLE;
   2010            TIMx->CCMR2 |= CCMR2_CH4_PWM2;
   2011            
   2012            /* Check if sampling AB in the middle of PWM is possible */
   2013            if (((uint16_t)(PWM_PERIOD-pBaseVars->hCntPhA) > pDParams_str->hTafter) &&
   2014                ((uint16_t)(PWM_PERIOD-pBaseVars->hCntPhB) > pDParams_str->hTafter))
   2015            {
   2016              TIMx->CCR4 = (uint32_t)(PWM_PERIOD) - 1u;
   2017              ((_CPWMC)this)->Vars_str.hSector = SECTOR_4; /* Dummy just for the GetPhaseCurrent */
   2018              if (pDOPAMPParams_str)
   2019              {
   2020                OPAMP_InitTypeDef OPAMP_InitStruct1;
   2021                OPAMP_InitTypeDef OPAMP_InitStruct2;
   2022                OPAMP_InitStruct1.OPAMP_InvertingInput = pDOPAMPParams_str->wOPAMP_InvertingInput;
   2023                OPAMP_InitStruct1.OPAMP_NonInvertingInput = pDOPAMPParams_str->wOPAMP_NonInvertingInput_PHA;
   2024                pLocalVars_Str->wOAMP1CR = R3_4_F30X_OPAMP_Init(pDOPAMPParams_str->wOPAMP_Selection,&OPAMP_InitStruct1);
   2025                OPAMP_InitStruct2.OPAMP_InvertingInput = pDOPAMPParams_str->wOPAMP2_InvertingInput;
   2026                OPAMP_InitStruct2.OPAMP_NonInvertingInput = pDOPAMPParams_str->wOPAMP2_NonInvertingInput_PHB;
   2027                pLocalVars_Str->wOAMP2CR = R3_4_F30X_OPAMP_Init(pDOPAMPParams_str->wOPAMP2_Selection,&OPAMP_InitStruct2);
   2028              }
   2029              else
   2030              {
   2031                pLocalVars_Str->wADC1_JSQR = pLocalVars_Str->wADC_JSQR_phA;
   2032                pLocalVars_Str->wADC2_JSQR = pLocalVars_Str->wADC_JSQR_phB;
   2033              }
   2034            }
   2035            else
   2036            {
   2037              if ((u16)(PWM_PERIOD-pBaseVars->hCntPhB) > pDParams_str->hTafter)
   2038              {
   2039                hCntSmp = PWM_PERIOD - 1u;
   2040              }
   2041              else
   2042              {
   2043                hDeltaDuty = (u16)(pBaseVars->hCntPhB - pBaseVars->hCntPhC);
   2044                
   2045                /* Definition of crossing point */
   2046                if (hDeltaDuty > (u16)(PWM_PERIOD-pBaseVars->hCntPhB)*2u) 
   2047                {
   2048                  hCntSmp = pBaseVars->hCntPhB - pDParams_str->hTbefore;
   2049                }
   2050                else
   2051                {
   2052                  hCntSmp = pBaseVars->hCntPhB + pDParams_str->hTafter;
   2053                  
   2054                  if (hCntSmp >= PWM_PERIOD)
   2055                  {
   2056                    /* Set CC4 as PWM mode 1 */
   2057                    TIMx->CCMR2 &= CCMR2_CH4_DISABLE;
   2058                    TIMx->CCMR2 |= CCMR2_CH4_PWM1;
   2059                    
   2060                    hCntSmp = (2u * PWM_PERIOD) - hCntSmp - 1u;
   2061                  }
   2062                }
   2063              }
   2064              
   2065              if (pDOPAMPParams_str)
   2066              {
   2067                OPAMP_InitTypeDef OPAMP_InitStruct1;
   2068                OPAMP_InitTypeDef OPAMP_InitStruct2;
   2069                OPAMP_InitStruct1.OPAMP_InvertingInput = pDOPAMPParams_str->wOPAMP_InvertingInput;
   2070                OPAMP_InitStruct1.OPAMP_NonInvertingInput = pDOPAMPParams_str->wOPAMP_NonInvertingInput_PHA;
   2071                pLocalVars_Str->wOAMP1CR = R3_4_F30X_OPAMP_Init(pDOPAMPParams_str->wOPAMP_Selection,&OPAMP_InitStruct1);
   2072                OPAMP_InitStruct2.OPAMP_InvertingInput = pDOPAMPParams_str->wOPAMP2_InvertingInput;
   2073                OPAMP_InitStruct2.OPAMP_NonInvertingInput = pDOPAMPParams_str->wOPAMP2_NonInvertingInput_PHC;
   2074                pLocalVars_Str->wOAMP2CR = R3_4_F30X_OPAMP_Init(pDOPAMPParams_str->wOPAMP2_Selection,&OPAMP_InitStruct2);
   2075              }
   2076              else
   2077              {
   2078                pLocalVars_Str->wADC1_JSQR = pLocalVars_Str->wADC_JSQR_phA;
   2079                pLocalVars_Str->wADC2_JSQR = pLocalVars_Str->wADC_JSQR_phC;
   2080              }
   2081              
   2082              /* Set TIMx_CH4 value */
   2083              TIMx->CCR4 = hCntSmp; 
   2084            }
   2085            return R3_4_F30X_WriteTIMRegisters(this);
   2086          }
   2087          
   2088          #if defined (CCMRAM)
   2089          #if defined (__ICCARM__)
   2090          #pragma location = ".ccmram"
   2091          #elif defined (__CC_ARM)
   2092          __attribute__((section ("ccmram")))
   2093          #endif
   2094          #endif
   2095          /**
   2096          * @brief  Configure the ADC for the current sampling related to sector 4.
   2097          *         It means set the sampling point via TIMx_Ch4 value and polarity
   2098          *         ADC sequence length and channels.
   2099          *         And call the WriteTIMRegisters method.
   2100          * @param  this related object of class CPWMC
   2101          * @retval none
   2102          */
   2103          static uint16_t R3_4_F30X_SetADCSampPointSect4(CPWMC this)
   2104          {
   2105            uint16_t hCntSmp, hDeltaDuty;
   2106            Vars_t *pBaseVars = &((_CPWMC) this)->Vars_str;
   2107            pDParams_t pDParams_str =  ((_DCR3_4_F30X_PWMC)(((_CPWMC) this)->DerivedClass))->pDParams_str;
   2108            DVars_t *pLocalVars_Str = &DCLASS_VARS;
   2109            TIM_TypeDef*  TIMx = pDParams_str->TIMx;
   2110            pR3_4_F30XOPAMPParams_t pDOPAMPParams_str = pDParams_str->pOPAMPParams;
   2111            
   2112            /* Set CC4 as PWM mode 2 (default) */
   2113            TIMx->CCMR2 &= CCMR2_CH4_DISABLE;
   2114            TIMx->CCMR2 |= CCMR2_CH4_PWM2;
   2115            
   2116            /* Check if sampling AB in the middle of PWM is possible */
   2117            if (((uint16_t)(PWM_PERIOD-pBaseVars->hCntPhA) > pDParams_str->hTafter) &&
   2118                ((uint16_t)(PWM_PERIOD-pBaseVars->hCntPhB) > pDParams_str->hTafter))
   2119            {
   2120              TIMx->CCR4 = (uint32_t)(PWM_PERIOD) - 1u;
   2121              ((_CPWMC)this)->Vars_str.hSector = SECTOR_4; /* Dummy just for the GetPhaseCurrent */
   2122              if (pDOPAMPParams_str)
   2123              {
   2124                OPAMP_InitTypeDef OPAMP_InitStruct1;
   2125                OPAMP_InitTypeDef OPAMP_InitStruct2;
   2126                OPAMP_InitStruct1.OPAMP_InvertingInput = pDOPAMPParams_str->wOPAMP_InvertingInput;
   2127                OPAMP_InitStruct1.OPAMP_NonInvertingInput = pDOPAMPParams_str->wOPAMP_NonInvertingInput_PHA;
   2128                pLocalVars_Str->wOAMP1CR = R3_4_F30X_OPAMP_Init(pDOPAMPParams_str->wOPAMP_Selection,&OPAMP_InitStruct1);
   2129                OPAMP_InitStruct2.OPAMP_InvertingInput = pDOPAMPParams_str->wOPAMP2_InvertingInput;
   2130                OPAMP_InitStruct2.OPAMP_NonInvertingInput = pDOPAMPParams_str->wOPAMP2_NonInvertingInput_PHB;
   2131                pLocalVars_Str->wOAMP2CR = R3_4_F30X_OPAMP_Init(pDOPAMPParams_str->wOPAMP2_Selection,&OPAMP_InitStruct2);
   2132              }
   2133              else
   2134              {
   2135                pLocalVars_Str->wADC1_JSQR = pLocalVars_Str->wADC_JSQR_phA;
   2136                pLocalVars_Str->wADC2_JSQR = pLocalVars_Str->wADC_JSQR_phB;
   2137              }
   2138            }
   2139            else
   2140            {
   2141              if ((u16)(PWM_PERIOD-pBaseVars->hCntPhC) > pDParams_str->hTafter)
   2142              {
   2143                hCntSmp = PWM_PERIOD - 1u;
   2144              }
   2145              else
   2146              {
   2147                hDeltaDuty = (u16)(pBaseVars->hCntPhC - pBaseVars->hCntPhB);
   2148                
   2149                /* Definition of crossing point */
   2150                if (hDeltaDuty > (u16)(PWM_PERIOD-pBaseVars->hCntPhC)*2u)
   2151                {
   2152                  hCntSmp = pBaseVars->hCntPhC - pDParams_str->hTbefore;
   2153                }
   2154                else
   2155                {
   2156                  hCntSmp = pBaseVars->hCntPhC + pDParams_str->hTafter;
   2157                  
   2158                  if (hCntSmp >= PWM_PERIOD)
   2159                  {
   2160                    /* Set CC4 as PWM mode 1 */
   2161                    TIMx->CCMR2 &= CCMR2_CH4_DISABLE;
   2162                    TIMx->CCMR2 |= CCMR2_CH4_PWM1;
   2163                    
   2164                    hCntSmp = (2u * PWM_PERIOD) - hCntSmp - 1u;
   2165                  }
   2166                }
   2167              }
   2168              
   2169              if (pDOPAMPParams_str)
   2170              {
   2171                OPAMP_InitTypeDef OPAMP_InitStruct1;
   2172                OPAMP_InitTypeDef OPAMP_InitStruct2;
   2173                OPAMP_InitStruct1.OPAMP_InvertingInput = pDOPAMPParams_str->wOPAMP_InvertingInput;
   2174                OPAMP_InitStruct1.OPAMP_NonInvertingInput = pDOPAMPParams_str->wOPAMP_NonInvertingInput_PHA;
   2175                pLocalVars_Str->wOAMP1CR = R3_4_F30X_OPAMP_Init(pDOPAMPParams_str->wOPAMP_Selection,&OPAMP_InitStruct1);
   2176                OPAMP_InitStruct2.OPAMP_InvertingInput = pDOPAMPParams_str->wOPAMP2_InvertingInput;
   2177                OPAMP_InitStruct2.OPAMP_NonInvertingInput = pDOPAMPParams_str->wOPAMP2_NonInvertingInput_PHB;
   2178                pLocalVars_Str->wOAMP2CR = R3_4_F30X_OPAMP_Init(pDOPAMPParams_str->wOPAMP2_Selection,&OPAMP_InitStruct2);
   2179              }
   2180              else
   2181              {
   2182                pLocalVars_Str->wADC1_JSQR = pLocalVars_Str->wADC_JSQR_phA;
   2183                pLocalVars_Str->wADC2_JSQR = pLocalVars_Str->wADC_JSQR_phB;
   2184              }
   2185              
   2186              /* Set TIMx_CH4 value */
   2187              TIMx->CCR4 = hCntSmp; 
   2188            }
   2189            return R3_4_F30X_WriteTIMRegisters(this);
   2190          }
   2191          
   2192          #if defined (CCMRAM)
   2193          #if defined (__ICCARM__)
   2194          #pragma location = ".ccmram"
   2195          #elif defined (__CC_ARM)
   2196          __attribute__((section ("ccmram")))
   2197          #endif
   2198          #endif
   2199          /**
   2200          * @brief  Configure the ADC for the current sampling related to sector 5.
   2201          *         It means set the sampling point via TIMx_Ch4 value and polarity
   2202          *         ADC sequence length and channels.
   2203          *         And call the WriteTIMRegisters method.
   2204          * @param  this related object of class CPWMC
   2205          * @retval none
   2206          */
   2207          static uint16_t R3_4_F30X_SetADCSampPointSect5(CPWMC this)
   2208          {
   2209            uint16_t hCntSmp, hDeltaDuty;
   2210            Vars_t *pBaseVars = &((_CPWMC) this)->Vars_str;
   2211            pDParams_t pDParams_str =  ((_DCR3_4_F30X_PWMC)(((_CPWMC) this)->DerivedClass))->pDParams_str;
   2212            DVars_t *pLocalVars_Str = &DCLASS_VARS;
   2213            TIM_TypeDef*  TIMx = pDParams_str->TIMx;
   2214            pR3_4_F30XOPAMPParams_t pDOPAMPParams_str = pDParams_str->pOPAMPParams;
   2215            
   2216            /* Set CC4 as PWM mode 2 (default) */
   2217            TIMx->CCMR2 &= CCMR2_CH4_DISABLE;
   2218            TIMx->CCMR2 |= CCMR2_CH4_PWM2;
   2219            
   2220            /* Check if sampling AB in the middle of PWM is possible */
   2221            if (((uint16_t)(PWM_PERIOD-pBaseVars->hCntPhA) > pDParams_str->hTafter) &&
   2222                ((uint16_t)(PWM_PERIOD-pBaseVars->hCntPhB) > pDParams_str->hTafter))
   2223            {
   2224              TIMx->CCR4 = (uint32_t)(PWM_PERIOD) - 1u;
   2225              ((_CPWMC)this)->Vars_str.hSector = SECTOR_4; /* Dummy just for the GetPhaseCurrent */
   2226              if (pDOPAMPParams_str)
   2227              {
   2228                OPAMP_InitTypeDef OPAMP_InitStruct1;
   2229                OPAMP_InitTypeDef OPAMP_InitStruct2;
   2230                OPAMP_InitStruct1.OPAMP_InvertingInput = pDOPAMPParams_str->wOPAMP_InvertingInput;
   2231                OPAMP_InitStruct1.OPAMP_NonInvertingInput = pDOPAMPParams_str->wOPAMP_NonInvertingInput_PHA;
   2232                pLocalVars_Str->wOAMP1CR = R3_4_F30X_OPAMP_Init(pDOPAMPParams_str->wOPAMP_Selection,&OPAMP_InitStruct1);
   2233                OPAMP_InitStruct2.OPAMP_InvertingInput = pDOPAMPParams_str->wOPAMP2_InvertingInput;
   2234                OPAMP_InitStruct2.OPAMP_NonInvertingInput = pDOPAMPParams_str->wOPAMP2_NonInvertingInput_PHB;
   2235                pLocalVars_Str->wOAMP2CR = R3_4_F30X_OPAMP_Init(pDOPAMPParams_str->wOPAMP2_Selection,&OPAMP_InitStruct2);
   2236              }
   2237              else
   2238              {
   2239                pLocalVars_Str->wADC1_JSQR = pLocalVars_Str->wADC_JSQR_phA;
   2240                pLocalVars_Str->wADC2_JSQR = pLocalVars_Str->wADC_JSQR_phB;
   2241              }
   2242            }
   2243            else
   2244            {
   2245              if ((u16)(PWM_PERIOD-pBaseVars->hCntPhC) > pDParams_str->hTafter)
   2246              {
   2247                hCntSmp = PWM_PERIOD - 1u;
   2248              }
   2249              else
   2250              {
   2251                hDeltaDuty = (u16)(pBaseVars->hCntPhC - pBaseVars->hCntPhA);
   2252                
   2253                /* Definition of crossing point */
   2254                if (hDeltaDuty > (u16)(PWM_PERIOD-pBaseVars->hCntPhC)*2u) 
   2255                {
   2256                  hCntSmp = pBaseVars->hCntPhC - pDParams_str->hTbefore;
   2257                }
   2258                else
   2259                {
   2260                  hCntSmp = pBaseVars->hCntPhC + pDParams_str->hTafter;
   2261                  
   2262                  if (hCntSmp >= PWM_PERIOD)
   2263                  {
   2264                    /* Set CC4 as PWM mode 1 */
   2265                    TIMx->CCMR2 &= CCMR2_CH4_DISABLE;
   2266                    TIMx->CCMR2 |= CCMR2_CH4_PWM1;
   2267                    
   2268                    hCntSmp = (2u * PWM_PERIOD) - hCntSmp - 1u;
   2269                  }
   2270                }
   2271              }
   2272              
   2273              if (pDOPAMPParams_str)
   2274              {
   2275                OPAMP_InitTypeDef OPAMP_InitStruct1;
   2276                OPAMP_InitTypeDef OPAMP_InitStruct2;
   2277                OPAMP_InitStruct1.OPAMP_InvertingInput = pDOPAMPParams_str->wOPAMP_InvertingInput;
   2278                OPAMP_InitStruct1.OPAMP_NonInvertingInput = pDOPAMPParams_str->wOPAMP_NonInvertingInput_PHA;
   2279                pLocalVars_Str->wOAMP1CR = R3_4_F30X_OPAMP_Init(pDOPAMPParams_str->wOPAMP_Selection,&OPAMP_InitStruct1);
   2280                OPAMP_InitStruct2.OPAMP_InvertingInput = pDOPAMPParams_str->wOPAMP2_InvertingInput;
   2281                OPAMP_InitStruct2.OPAMP_NonInvertingInput = pDOPAMPParams_str->wOPAMP2_NonInvertingInput_PHB;
   2282                pLocalVars_Str->wOAMP2CR = R3_4_F30X_OPAMP_Init(pDOPAMPParams_str->wOPAMP2_Selection,&OPAMP_InitStruct2);
   2283              }
   2284              else
   2285              {
   2286                pLocalVars_Str->wADC1_JSQR = pLocalVars_Str->wADC_JSQR_phA;
   2287                pLocalVars_Str->wADC2_JSQR = pLocalVars_Str->wADC_JSQR_phB;
   2288              }
   2289              
   2290              /* Set TIMx_CH4 value */
   2291              TIMx->CCR4 = hCntSmp;
   2292            }
   2293            return R3_4_F30X_WriteTIMRegisters(this);
   2294          }
   2295          
   2296          #if defined (CCMRAM)
   2297          #if defined (__ICCARM__)
   2298          #pragma location = ".ccmram"
   2299          #elif defined (__CC_ARM)
   2300          __attribute__((section ("ccmram")))
   2301          #endif
   2302          #endif
   2303          /**
   2304          * @brief  Configure the ADC for the current sampling related to sector 6.
   2305          *         It means set the sampling point via TIMx_Ch4 value and polarity
   2306          *         ADC sequence length and channels.
   2307          *         And call the WriteTIMRegisters method.
   2308          * @param  this related object of class CPWMC
   2309          * @retval none
   2310          */
   2311          static uint16_t R3_4_F30X_SetADCSampPointSect6(CPWMC this)
   2312          {
   2313            uint16_t hCntSmp, hDeltaDuty;
   2314            Vars_t *pBaseVars = &((_CPWMC) this)->Vars_str;
   2315            pDParams_t pDParams_str =  ((_DCR3_4_F30X_PWMC)(((_CPWMC) this)->DerivedClass))->pDParams_str;
   2316            DVars_t *pLocalVars_Str = &DCLASS_VARS;
   2317            TIM_TypeDef*  TIMx = pDParams_str->TIMx;
   2318            pR3_4_F30XOPAMPParams_t pDOPAMPParams_str = pDParams_str->pOPAMPParams;
   2319            
   2320            /* Set CC4 as PWM mode 2 (default) */
   2321            TIMx->CCMR2 &= CCMR2_CH4_DISABLE;
   2322            TIMx->CCMR2 |= CCMR2_CH4_PWM2;
   2323            
   2324            /* Check if sampling AB in the middle of PWM is possible */
   2325            if (((uint16_t)(PWM_PERIOD-pBaseVars->hCntPhA) > pDParams_str->hTafter) &&
   2326                ((uint16_t)(PWM_PERIOD-pBaseVars->hCntPhB) > pDParams_str->hTafter))
   2327            {
   2328              TIMx->CCR4 = (uint32_t)(PWM_PERIOD) - 1u;
   2329              ((_CPWMC)this)->Vars_str.hSector = SECTOR_4; /* Dummy just for the GetPhaseCurrent */
   2330              if (pDOPAMPParams_str)
   2331              {
   2332                OPAMP_InitTypeDef OPAMP_InitStruct1;
   2333                OPAMP_InitTypeDef OPAMP_InitStruct2;
   2334                OPAMP_InitStruct1.OPAMP_InvertingInput = pDOPAMPParams_str->wOPAMP_InvertingInput;
   2335                OPAMP_InitStruct1.OPAMP_NonInvertingInput = pDOPAMPParams_str->wOPAMP_NonInvertingInput_PHA;
   2336                pLocalVars_Str->wOAMP1CR = R3_4_F30X_OPAMP_Init(pDOPAMPParams_str->wOPAMP_Selection,&OPAMP_InitStruct1);
   2337                OPAMP_InitStruct2.OPAMP_InvertingInput = pDOPAMPParams_str->wOPAMP2_InvertingInput;
   2338                OPAMP_InitStruct2.OPAMP_NonInvertingInput = pDOPAMPParams_str->wOPAMP2_NonInvertingInput_PHB;
   2339                pLocalVars_Str->wOAMP2CR = R3_4_F30X_OPAMP_Init(pDOPAMPParams_str->wOPAMP2_Selection,&OPAMP_InitStruct2);
   2340              }
   2341              else
   2342              {
   2343                pLocalVars_Str->wADC1_JSQR = pLocalVars_Str->wADC_JSQR_phA;
   2344                pLocalVars_Str->wADC2_JSQR = pLocalVars_Str->wADC_JSQR_phB;
   2345              }
   2346            }
   2347            else
   2348            {
   2349              if ((u16)(PWM_PERIOD-pBaseVars->hCntPhA) > pDParams_str->hTafter)
   2350              {
   2351                hCntSmp = PWM_PERIOD - 1u;
   2352              }
   2353              else
   2354              {
   2355                hDeltaDuty = (u16)(pBaseVars->hCntPhA - pBaseVars->hCntPhC);
   2356                
   2357                /* Definition of crossing point */
   2358                if (hDeltaDuty > (u16)(PWM_PERIOD-pBaseVars->hCntPhA)*2u) 
   2359                {
   2360                  hCntSmp = pBaseVars->hCntPhA - pDParams_str->hTbefore;
   2361                }
   2362                else
   2363                {
   2364                  hCntSmp = pBaseVars->hCntPhA + pDParams_str->hTafter;
   2365                  
   2366                  if (hCntSmp >= PWM_PERIOD)
   2367                  {   
   2368                    /* Set CC4 as PWM mode 1 */
   2369                    TIMx->CCMR2 &= CCMR2_CH4_DISABLE;
   2370                    TIMx->CCMR2 |= CCMR2_CH4_PWM1;
   2371                    
   2372                    hCntSmp = (2u * PWM_PERIOD) - hCntSmp - 1u;
   2373                  }
   2374                }
   2375              }
   2376              
   2377              if (pDOPAMPParams_str)
   2378              {
   2379                OPAMP_InitTypeDef OPAMP_InitStruct1;
   2380                OPAMP_InitTypeDef OPAMP_InitStruct2;
   2381                OPAMP_InitStruct1.OPAMP_InvertingInput = pDOPAMPParams_str->wOPAMP_InvertingInput;
   2382                OPAMP_InitStruct1.OPAMP_NonInvertingInput = pDOPAMPParams_str->wOPAMP_NonInvertingInput_PHB;
   2383                pLocalVars_Str->wOAMP1CR = R3_4_F30X_OPAMP_Init(pDOPAMPParams_str->wOPAMP_Selection,&OPAMP_InitStruct1);
   2384                OPAMP_InitStruct2.OPAMP_InvertingInput = pDOPAMPParams_str->wOPAMP2_InvertingInput;
   2385                OPAMP_InitStruct2.OPAMP_NonInvertingInput = pDOPAMPParams_str->wOPAMP2_NonInvertingInput_PHC;
   2386                pLocalVars_Str->wOAMP2CR = R3_4_F30X_OPAMP_Init(pDOPAMPParams_str->wOPAMP2_Selection,&OPAMP_InitStruct2);
   2387              }
   2388              else
   2389              {
   2390                pLocalVars_Str->wADC1_JSQR = pLocalVars_Str->wADC_JSQR_phB;
   2391                pLocalVars_Str->wADC2_JSQR = pLocalVars_Str->wADC_JSQR_phC;
   2392              }
   2393              
   2394              /* Set TIMx_CH4 value */
   2395              TIMx->CCR4 = hCntSmp;
   2396            }
   2397            return R3_4_F30X_WriteTIMRegisters(this);
   2398          }
   2399          
   2400          #if defined (CCMRAM)
   2401          #if defined (__ICCARM__)
   2402          #pragma location = ".ccmram"
   2403          #elif defined (__CC_ARM)
   2404          __attribute__((section ("ccmram")))
   2405          #endif
   2406          #endif
   2407          /**
   2408          * @brief  It contains the TIMx Update event interrupt
   2409          * @param  this: related object of class CR3_4_F30X_PWMC
   2410          * @retval none
   2411          */
   2412          static void *R3_4_F30X_IRQHandler(void *this, unsigned char flag)
   2413          {
   2414            pVars_t pVars_str = &CLASS_VARS;
   2415            pDParams_t pDParams_str = DCLASS_PARAMS;
   2416            if (flag == 2u)
   2417            {
   2418              if (DCLASS_VARS.BrakeActionLock == FALSE)
   2419              {
   2420                if ((pDParams_str->LowSideOutputs)== ES_GPIO)
   2421                {
   2422                  GPIO_WriteBit(pDParams_str->hCh1NPort, pDParams_str->hCh1NPin, Bit_RESET);
   2423                  GPIO_WriteBit(pDParams_str->hCh2NPort, pDParams_str->hCh2NPin, Bit_RESET);
   2424                  GPIO_WriteBit(pDParams_str->hCh3NPort, pDParams_str->hCh3NPin, Bit_RESET);
   2425                }
   2426              }
   2427              DCLASS_VARS.OverCurrentFlag = TRUE;
   2428            }
   2429            else if (flag == 3u)
   2430            {
   2431              DCLASS_PARAMS->TIMx->BDTR |= TIM_OSSIState_Enable;
   2432              DCLASS_VARS.OverVoltageFlag = TRUE;
   2433              DCLASS_VARS.BrakeActionLock = TRUE;
   2434            }
   2435            else
   2436            {
   2437            }
   2438            return &(pVars_str->bMotor);
   2439          }
   2440          
   2441          /**
   2442          * @brief  Execute a regular conversion using ADCx. 
   2443          *         The function is not re-entrant (can't executed twice at the same time)
   2444          * @param  this related object of class CR3_4_F30X_PWMC
   2445          * @retval It returns converted value or oxFFFF for conversion error
   2446          */
   2447          static uint16_t R3_4_F30X_ExecRegularConv(CPWMC this, uint8_t bChannel)
   2448          {
   2449            pDVars_t pDVars_str = &DCLASS_VARS;
   2450            pDParams_t pDParams_str = DCLASS_PARAMS;
   2451            ADC_TypeDef* ADCx = pDParams_str->regconvADCx;
   2452            
   2453            ADCx->SQR1 = (uint32_t)(bChannel) << 6;
   2454            
   2455            ADCx->DR;
   2456            ADCx->CR = ADC_CR_ADSTART;
   2457            
   2458            /* Wait until end of regular conversion */
   2459            while ((ADCx->ISR & ADC_ISR_EOC) == 0u)
   2460            {
   2461            }
   2462            
   2463            pDVars_str->hRegConv = (uint16_t)(ADCx->DR);
   2464            return (pDVars_str->hRegConv);
   2465          }
   2466          
   2467          /**
   2468          * @brief  It sets the specified sampling time for the specified ADC channel
   2469          *         on ADCx. It must be called once for each channel utilized by user
   2470          * @param  ADC channel, sampling time
   2471          * @retval none
   2472          */
   2473          static void R3_4_F30X_ADC_SetSamplingTime(CPWMC this, ADConv_t ADConv_struct)
   2474          { 
   2475            pDParams_t pDParams_str = DCLASS_PARAMS;
   2476            uint32_t tmpreg2 = 0u;
   2477            uint8_t ADC_Channel = ADConv_struct.Channel;
   2478            uint8_t ADC_SampleTime = ADConv_struct.SamplTime;
   2479            
   2480            /* Channel sampling configuration */
   2481            /* if ADC_Channel_10 ... ADC_Channel_18 is selected */
   2482            if (ADC_Channel > ADC_Channel_9)
   2483            {
   2484              uint32_t wAux,wAux2;
   2485              /* Get the old register value */
   2486              /* Calculate the mask to clear */
   2487              wAux = ADC_SMPR2_SMP10;
   2488              wAux2 = 3u * ((uint32_t)(ADC_Channel) - 10u);
   2489              tmpreg2 =  wAux << wAux2;
   2490              /* Clear the old channel sample time */
   2491              pDParams_str->regconvADCx->SMPR2 &= ~tmpreg2;
   2492              /* Calculate the mask to set */
   2493              wAux = (uint32_t)(ADC_SampleTime);
   2494              pDParams_str->regconvADCx->SMPR2 |=  wAux << wAux2;
   2495              
   2496            }
   2497            else /* ADC_Channel include in ADC_Channel_[0..9] */
   2498            {
   2499              uint32_t wAux,wAux2;
   2500              /* Get the old register value */
   2501              /* Calculate the mask to clear */
   2502              wAux = ADC_SMPR1_SMP1;
   2503              wAux2 = 3u * ((uint32_t)(ADC_Channel) - 1u);
   2504              tmpreg2 =  wAux << wAux2;
   2505              /* Clear the old channel sample time */
   2506              pDParams_str->regconvADCx->SMPR1 &= ~tmpreg2;
   2507              /* Calculate the mask to set */
   2508              wAux = (uint32_t)(ADC_SampleTime);
   2509              wAux2 = 3u * ((uint32_t)(ADC_Channel));
   2510              pDParams_str->regconvADCx->SMPR1 |= wAux << wAux2;
   2511            }
   2512          }
   2513          /**
   2514          * @brief  It is used to check if an overcurrent occurred since last call.
   2515          * @param  this related object of class CPWMC
   2516          * @retval uint16_t It returns MC_BREAK_IN whether an overcurrent has been 
   2517          *                  detected since last method call, MC_NO_FAULTS otherwise.
   2518          */
   2519          static uint16_t R3_4_F30X_IsOverCurrentOccurred(CPWMC this)
   2520          {
   2521            pDVars_t pDVars_str = &DCLASS_VARS;
   2522            uint16_t retVal = MC_NO_FAULTS;
   2523            
   2524            if (pDVars_str->OverVoltageFlag == TRUE)
   2525            {
   2526              retVal = MC_OVER_VOLT;
   2527              pDVars_str->OverVoltageFlag = FALSE;
   2528            }
   2529            
   2530            if (pDVars_str->OverCurrentFlag == TRUE )
   2531            {
   2532              retVal |= MC_BREAK_IN;
   2533              pDVars_str->OverCurrentFlag = FALSE;
   2534            }
   2535            
   2536            return retVal;
   2537          }
   2538          
   2539          /**
   2540          * @brief  It is used to configure the analog output used for protection 
   2541          *         thresholds.
   2542          * @param  DAC_Channel: the selected DAC channel. 
   2543          *          This parameter can be:
   2544          *            @arg DAC_Channel_1: DAC Channel1 selected
   2545          *            @arg DAC_Channel_2: DAC Channel2 selected
   2546          * @param  hDACVref Value of DAC reference expressed as 16bit unsigned integer.
   2547          *         Ex. 0 = 0V 65536 = VDD_DAC.
   2548          * @retval none
   2549          */
   2550          static void R3_4_F30X_SetAOReferenceVoltage(uint32_t DAC_Channel, uint16_t hDACVref)
   2551          { 
   2552            DAC_InitTypeDef DAC_InitStructure;
   2553            
   2554            RCC_APB1PeriphClockCmd(RCC_APB1Periph_DAC, ENABLE);
   2555            
   2556            /* DAC Configuration */
   2557            DAC_InitStructure.DAC_Trigger = DAC_Trigger_Software;
   2558            DAC_InitStructure.DAC_WaveGeneration = DAC_WaveGeneration_None;
   2559            DAC_InitStructure.DAC_Buffer_Switch = DAC_BufferSwitch_Enable;
   2560            DAC_InitStructure.DAC_LFSRUnmask_TriangleAmplitude=DAC_TriangleAmplitude_1;
   2561            DAC_Init(DAC1, DAC_Channel, &DAC_InitStructure);
   2562            
   2563            if (DAC_Channel == DAC_Channel_2)
   2564            {
   2565              DAC_SetChannel2Data(DAC1, DAC_Align_12b_L,hDACVref);
   2566            }
   2567            else
   2568            {
   2569              DAC_SetChannel1Data(DAC1, DAC_Align_12b_L,hDACVref);
   2570            }
   2571            
   2572            /* Enable DAC Channel */
   2573            DAC_SoftwareTriggerCmd(DAC1, DAC_Channel,ENABLE);
   2574            DAC_Cmd(DAC1, DAC_Channel, ENABLE);
   2575          }
   2576          
   2577          /**
   2578            * @brief  It is an internal function used to compute the GPIO Source 
   2579            *         value starting from GPIO pin value. The GPIO Source value 
   2580            *         is used for AF remapping.
   2581            * @param  GPIO_Pin Pin value to be converted.
   2582            * @retval uint16_t The GPIO pin source value converted.
   2583            */
   2584          static uint16_t F30X_GPIOPin2Source(uint16_t GPIO_Pin)
   2585          {
   2586            uint16_t GPIO_Sourcex = 0u;
   2587            
   2588            while (GPIO_Pin != 0x01u)
   2589            {
   2590              GPIO_Pin = GPIO_Pin >> 1u;
   2591              GPIO_Sourcex++;
   2592            }
   2593            return GPIO_Sourcex;
   2594          }
   2595          
   2596          uint32_t R3_4_F30X_ADC_InjectedChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime, uint8_t SequencerLength, uint16_t ADC_ExternalTriggerInjectedPolarity, uint16_t ADC_ExternalTriggerInjected)
   2597          {
   2598            uint32_t tmpreg1 = 0u, tmpreg2 = 0u, tmpregA = 0u;
   2599            uint32_t wAux,wAux2;
   2600            
   2601            /*  ADC_InjectedSequencerLengthConfig(ADCx,1); */
   2602            tmpregA = ADCx->JSQR;
   2603            /* Clear the old injected sequnence lenght JL bits */
   2604            tmpregA &= ~(uint32_t)ADC_JSQR_JL;
   2605            /* Set the injected sequnence lenght JL bits */
   2606            tmpregA |= ((uint32_t)(SequencerLength) - 1u); /* first value is sequencer lenght */
   2607            
   2608            /* Disable the selected ADC conversion on external event */
   2609            tmpregA &= ~ADC_JSQR_JEXTEN;
   2610            tmpregA |= ADC_ExternalTriggerInjectedPolarity; 
   2611           
   2612            /* Disable the selected ADC conversion on external event */
   2613            tmpregA &= ~ADC_JSQR_JEXTSEL;
   2614            tmpregA |= ADC_ExternalTriggerInjected;
   2615          
   2616            /* Channel sampling configuration */
   2617            /* if ADC_Channel_10 ... ADC_Channel_18 is selected */
   2618            if (ADC_Channel > ADC_Channel_9)
   2619            {
   2620              /* Get the old register value */
   2621              tmpreg1 = ADCx->SMPR2;
   2622              /* Calculate the mask to clear */
   2623              wAux = ADC_SMPR2_SMP10;
   2624              wAux2 = 3u * ((uint32_t)(ADC_Channel) - 10u);
   2625              tmpreg2 = wAux << wAux2;
   2626              /* Clear the old channel sample time */
   2627              tmpreg1 &= ~tmpreg2;
   2628              /* Calculate the mask to set */
   2629              wAux = (uint32_t)(ADC_SampleTime);
   2630              tmpreg2 = wAux << wAux2;
   2631              /* Set the new channel sample time */
   2632              tmpreg1 |= tmpreg2;
   2633              /* Store the new register value */
   2634              ADCx->SMPR2 = tmpreg1;
   2635            }
   2636            else if (ADC_Channel != 0u)
   2637            {
   2638              /* Get the old register value */
   2639              tmpreg1 = ADCx->SMPR1;
   2640              /* Calculate the mask to clear */
   2641              wAux = ADC_SMPR1_SMP0;
   2642              wAux2 = 3u * (uint32_t)(ADC_Channel);
   2643              tmpreg2 =  wAux << wAux2;
   2644              /* Clear the old channel sample time */
   2645              tmpreg1 &= ~tmpreg2;
   2646              /* Calculate the mask to set */
   2647              wAux = (uint32_t)ADC_SampleTime;
   2648              wAux2 = 3u * (uint32_t)(ADC_Channel);
   2649              tmpreg2 =  wAux << wAux2;
   2650              /* Set the new channel sample time */
   2651              tmpreg1 |= tmpreg2;
   2652              /* Store the new register value */
   2653              ADCx->SMPR1 = tmpreg1;
   2654            }
   2655            else
   2656            {
   2657            }
   2658          
   2659            /* Rank configuration */
   2660            /* Get the old register value */
   2661            tmpreg1 = tmpregA;
   2662            /* Calculate the mask to clear */
   2663            wAux = ADC_JSQR_JSQ1;
   2664            wAux2 = 6u * ((uint32_t)(Rank) - 1u);
   2665            tmpreg2 = wAux << wAux2;
   2666            /* Clear the old SQx bits for the selected rank */
   2667            tmpreg1 &= ~tmpreg2;
   2668            /* Calculate the mask to set */
   2669            wAux = ADC_Channel;
   2670            wAux2 = 6u * (uint32_t)(Rank) + 2u;
   2671            tmpreg2 = wAux << wAux2;
   2672            /* Set the SQx bits for the selected rank */
   2673            tmpreg1 |= tmpreg2;
   2674            /* Store the new register value */
   2675            
   2676            return (tmpreg1);
   2677          }
   2678          
   2679          /**
   2680            * @brief  Initializes the OPAMP peripheral according to the specified parameters
   2681            *         in OPAMP_InitStruct
   2682            * @note   If the selected OPAMP is locked, initialization can't be performed.
   2683            *         To unlock the configuration, perform a system reset.
   2684            * @param  OPAMP_Selection: the selected OPAMP. 
   2685            *          This parameter can be OPAMP_Selection_OPAMPx where x can be 1 to 4
   2686            *          to select the OPAMP peripheral.
   2687            * @param  OPAMP_InitStruct: pointer to an OPAMP_InitTypeDef structure that contains 
   2688            *         the configuration information for the specified OPAMP peripheral.
   2689            *           - OPAMP_InvertingInput specifies the inverting input of OPAMP
   2690            *           - OPAMP_NonInvertingInput specifies the non inverting input of OPAMP
   2691            * @retval None
   2692            */
   2693          uint32_t R3_4_F30X_OPAMP_Init(uint32_t OPAMP_Selection, OPAMP_InitTypeDef* OPAMP_InitStruct)
   2694          {
   2695            uint32_t tmpreg = 0u;
   2696            uint32_t wAux;
   2697          
   2698            /*!< Get the OPAMPx_CSR register value */
   2699            wAux = OPAMP_BASE + OPAMP_Selection;
   2700            tmpreg = *(__IO uint32_t *) (wAux);
   2701          
   2702            /*!< Clear the inverting and non inverting bits selection bits */
   2703            tmpreg &= (uint32_t) (OPAMP_CSR_DEFAULT_MASK);
   2704          
   2705            /*!< Configure OPAMP: inverting and non inverting inputs */
   2706            tmpreg |= (uint32_t)(OPAMP_InitStruct->OPAMP_InvertingInput | OPAMP_InitStruct->OPAMP_NonInvertingInput);
   2707            
   2708            return tmpreg;
   2709          }
   2710          
   2711          /**
   2712            * @brief  Fills each TIM_BDTRInitStruct member with its default value.
   2713            * @param  TIM_BDTRInitStruct: pointer to a TIM_BDTRInitTypeDef structure which
   2714            *         will be initialized.
   2715            * @retval None
   2716            */
   2717          static void TIM_BDTRStructInit_MC(TIM_BDTRInitTypeDef_MC* TIM_BDTRInitStruct)
   2718          {
   2719            /* Set the default configuration */
   2720            TIM_BDTRInitStruct->TIM_OSSRState = TIM_OSSRState_Disable;
   2721            TIM_BDTRInitStruct->TIM_OSSIState = TIM_OSSIState_Disable;
   2722            TIM_BDTRInitStruct->TIM_LOCKLevel = TIM_LOCKLevel_OFF;
   2723            TIM_BDTRInitStruct->TIM_DeadTime = 0x00u;
   2724            TIM_BDTRInitStruct->TIM_Break = TIM_Break_Disable;
   2725            TIM_BDTRInitStruct->TIM_BreakPolarity = TIM_BreakPolarity_Low;
   2726            TIM_BDTRInitStruct->TIM_AutomaticOutput = TIM_AutomaticOutput_Disable;
   2727            TIM_BDTRInitStruct->TIM_Break2 = TIM_Break2_Disable;
   2728            TIM_BDTRInitStruct->TIM_Break2Polarity = TIM_Break2Polarity_Low;
   2729            TIM_BDTRInitStruct->TIM_Break1Filter = 0x00u;
   2730            TIM_BDTRInitStruct->TIM_Break2Filter = 0x00u;
   2731          }
   2732          
   2733          /**
   2734            * @brief  Configures the Break feature, dead time, Lock level, OSSI/OSSR State
   2735            *         and the AOE(automatic output enable).
   2736            * @param  TIMx: where x can be  1, 8, 15, 16 or 17 to select the TIM 
   2737            * @param  TIM_BDTRInitStruct: pointer to a TIM_BDTRInitTypeDef_MC structure that
   2738            *         contains the BDTR Register configuration  information for the TIM peripheral.
   2739            * @retval None
   2740            */
   2741          static void TIM_BDTRConfig_MC(TIM_TypeDef* TIMx, TIM_BDTRInitTypeDef_MC *TIM_BDTRInitStruct)
   2742          {
   2743            /* Check the parameters */
   2744          #ifndef MISRA_C_2004_BUILD
   2745            assert_param(IS_TIM_LIST6_PERIPH(TIMx));
   2746            assert_param(IS_TIM_OSSR_STATE(TIM_BDTRInitStruct->TIM_OSSRState));
   2747            assert_param(IS_TIM_OSSI_STATE(TIM_BDTRInitStruct->TIM_OSSIState));
   2748            assert_param(IS_TIM_LOCK_LEVEL(TIM_BDTRInitStruct->TIM_LOCKLevel));
   2749            assert_param(IS_TIM_BREAK_STATE(TIM_BDTRInitStruct->TIM_Break));
   2750            assert_param(IS_TIM_BREAK_POLARITY(TIM_BDTRInitStruct->TIM_BreakPolarity));
   2751            assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(TIM_BDTRInitStruct->TIM_AutomaticOutput));
   2752            assert_param(IS_TIM_BREAK2_STATE(TIM_BDTRInitStruct->TIM_Break2));
   2753            assert_param(IS_TIM_BREAK2_POLARITY(TIM_BDTRInitStruct->TIM_Break2Polarity));
   2754            assert_param(IS_TIM_BREAK1_FILTER(TIM_BDTRInitStruct->TIM_Break1Filter));
   2755            assert_param(IS_TIM_BREAK2_FILTER(TIM_BDTRInitStruct->TIM_Break2Filter));
   2756          #endif
   2757            
   2758            /* Set the Lock level, the Break enable Bit and the Polarity, the OSSR State,
   2759               the OSSI State, the dead time value and the Automatic Output Enable Bit */
   2760            TIMx->BDTR = (uint32_t)TIM_BDTRInitStruct->TIM_OSSRState | TIM_BDTRInitStruct->TIM_OSSIState |
   2761              TIM_BDTRInitStruct->TIM_LOCKLevel | TIM_BDTRInitStruct->TIM_DeadTime |
   2762                TIM_BDTRInitStruct->TIM_Break | TIM_BDTRInitStruct->TIM_BreakPolarity |
   2763                  TIM_BDTRInitStruct->TIM_AutomaticOutput|TIM_BDTRInitStruct->TIM_Break2 |
   2764                    TIM_BDTRInitStruct->TIM_Break2Polarity|((uint32_t)TIM_BDTRInitStruct->TIM_Break1Filter << 16) |
   2765                      ((uint32_t)TIM_BDTRInitStruct->TIM_Break2Filter << 20);
   2766          }
   2767          
   2768          /**
   2769          * @brief  It is used to set the PWM mode for R/L detection.
   2770          * @param  this related object of class CPWMC
   2771          * @param  hDuty to be applied in u16
   2772          * @retval none
   2773          */
   2774          static void R3_4_F30X_RLDetectionModeEnable(CPWMC this)
   2775          {
   2776            pVars_t pVars_str = &CLASS_VARS;
   2777            pDVars_t pDVars_str = &DCLASS_VARS;
   2778            pDParams_t pDParams_str = DCLASS_PARAMS;
   2779            TIM_TypeDef*  TIMx = pDParams_str->TIMx;
   2780            
   2781            if (pVars_str->RLDetectionMode == FALSE)
   2782            {
   2783              /*  Channel1 configuration */
   2784              TIM_SelectOCxM(TIMx, TIM_Channel_1, TIM_OCMode_PWM1);
   2785              TIM_CCxCmd(TIMx, TIM_Channel_1, TIM_CCx_Enable);
   2786              TIM_CCxNCmd(TIMx, TIM_Channel_1, TIM_CCxN_Disable);
   2787              
   2788              TIM_SetCompare1(TIMx, 0u);
   2789              
   2790              /*  Channel2 configuration */
   2791              if ((pDParams_str-> LowSideOutputs)== LS_PWM_TIMER)
   2792              {
   2793                TIM_SelectOCxM(TIMx, TIM_Channel_2, TIM_OCMode_Active);
   2794                TIM_CCxCmd(TIMx, TIM_Channel_2, TIM_CCx_Disable);
   2795                TIM_CCxNCmd(TIMx, TIM_Channel_2, TIM_CCxN_Enable);
   2796              }
   2797              else if ((pDParams_str->LowSideOutputs)== ES_GPIO)
   2798              {
   2799                TIM_SelectOCxM(TIMx, TIM_Channel_2, TIM_OCMode_Inactive);
   2800                TIM_CCxCmd(TIMx, TIM_Channel_2, TIM_CCx_Enable);
   2801                TIM_CCxNCmd(TIMx, TIM_Channel_2, TIM_CCxN_Disable);
   2802              }
   2803              else
   2804              {
   2805              }
   2806              
   2807              /*  Channel3 configuration */
   2808              TIM_SelectOCxM(TIMx, TIM_Channel_3, TIM_OCMode_PWM2);
   2809              TIM_CCxCmd(TIMx, TIM_Channel_3, TIM_CCx_Disable);
   2810              TIM_CCxNCmd(TIMx, TIM_Channel_3, TIM_CCxN_Disable);
   2811              
   2812              pDVars_str->wADC_JSQR_phA = R3_4_F30X_ADC_InjectedChannelConfig(pDVars_str->ADCx_1, pDParams_str->bIbChannel, 1u, pDParams_str->b_IbSamplingTime, 1u, ADC_ExternalTrigInjecEventEdge_RisingEdge, pDVars_str->ADC_ExternalTriggerInjected);
   2813              pDVars_str->wADC_JSQR_phB = R3_4_F30X_ADC_InjectedChannelConfig(pDVars_str->ADCx_2, pDParams_str->bIbChannel, 1u, pDParams_str->b_IbSamplingTime, 1u, ADC_ExternalTrigInjecEventEdge_RisingEdge, ADC_ExternalTrigInjecConvEvent_8);
   2814              
   2815              pDVars_str->wPhaseAOffset = pDVars_str->wPhaseBOffset; /* Use only the offset of phB */
   2816            }
   2817            
   2818            ((_CPWMC)this)->Methods_str.pPWMC_GetPhaseCurrents = &R3_4_F30X_RLGetPhaseCurrents;
   2819            ((_CPWMC)this)->Methods_str.pPWMC_TurnOnLowSides = &R3_4_F30X_RLTurnOnLowSides;
   2820            ((_CPWMC)this)->Methods_str.pPWMC_SwitchOnPWM = &R3_4_F30X_RLSwitchOnPWM;
   2821            ((_CPWMC)this)->Methods_str.pPWMC_SwitchOffPWM = &R3_4_F30X_RLSwitchOffPWM;
   2822            
   2823            pVars_str->RLDetectionMode = TRUE;
   2824          }
   2825          
   2826          /**
   2827          * @brief  It is used to disable the PWM mode in 6-step.
   2828          * @param  this related object of class CPWMC
   2829          * @retval none
   2830          */
   2831          static void R3_4_F30X_RLDetectionModeDisable(CPWMC this)
   2832          {
   2833            pVars_t pVars_str = &CLASS_VARS;
   2834            pDVars_t pDVars_str = &DCLASS_VARS;
   2835            pDParams_t pDParams_str = DCLASS_PARAMS;
   2836            TIM_TypeDef*  TIMx = pDParams_str->TIMx;
   2837            
   2838            if (pVars_str->RLDetectionMode == TRUE)
   2839            {
   2840              /*  Channel1 configuration */
   2841              TIM_SelectOCxM(TIMx, TIM_Channel_1, TIM_OCMode_PWM1);
   2842              TIM_CCxCmd(TIMx, TIM_Channel_1, TIM_CCx_Enable);
   2843              
   2844              if ((pDParams_str-> LowSideOutputs)== LS_PWM_TIMER)
   2845              {
   2846                TIM_CCxNCmd(TIMx, TIM_Channel_1, TIM_CCxN_Enable);
   2847              }
   2848              else if ((pDParams_str->LowSideOutputs)== ES_GPIO)
   2849              {
   2850                TIM_CCxNCmd(TIMx, TIM_Channel_1, TIM_CCxN_Disable);
   2851              }
   2852              else
   2853              {
   2854              }
   2855              
   2856              TIM_SetCompare1(TIMx, (uint32_t)(pDVars_str->Half_PWMPeriod) >> 1);
   2857              
   2858              /*  Channel2 configuration */
   2859              TIM_SelectOCxM(TIMx, TIM_Channel_2, TIM_OCMode_PWM1);
   2860              TIM_CCxCmd(TIMx, TIM_Channel_2, TIM_CCx_Enable);
   2861              
   2862              if ((pDParams_str-> LowSideOutputs)== LS_PWM_TIMER)
   2863              {
   2864                TIM_CCxNCmd(TIMx, TIM_Channel_2, TIM_CCxN_Enable);
   2865              }
   2866              else if ((pDParams_str->LowSideOutputs)== ES_GPIO)
   2867              {
   2868                TIM_CCxNCmd(TIMx, TIM_Channel_2, TIM_CCxN_Disable);
   2869              }
   2870              else
   2871              {
   2872              }
   2873              
   2874              TIM_SetCompare2(TIMx, (uint32_t)(pDVars_str->Half_PWMPeriod) >> 1);
   2875              
   2876              /*  Channel3 configuration */
   2877              TIM_SelectOCxM(TIMx, TIM_Channel_3, TIM_OCMode_PWM1);
   2878              TIM_CCxCmd(TIMx, TIM_Channel_3, TIM_CCx_Enable);
   2879              
   2880              if ((pDParams_str-> LowSideOutputs)== LS_PWM_TIMER)
   2881              {
   2882                TIM_CCxNCmd(TIMx, TIM_Channel_3, TIM_CCxN_Enable);
   2883              }
   2884              else if ((pDParams_str->LowSideOutputs)== ES_GPIO)
   2885              {
   2886                TIM_CCxNCmd(TIMx, TIM_Channel_3, TIM_CCxN_Disable);
   2887              }
   2888              else
   2889              {
   2890              }
   2891              
   2892              TIM_SetCompare3(TIMx, (uint32_t)(pDVars_str->Half_PWMPeriod) >> 1);
   2893              
   2894              pDVars_str->wADC_JSQR_phA = R3_4_F30X_ADC_InjectedChannelConfig(pDVars_str->ADCx_1, pDParams_str->bIaChannel, 1u, pDParams_str->b_IaSamplingTime, 1u, ADC_ExternalTrigInjecEventEdge_RisingEdge, pDVars_str->ADC_ExternalTriggerInjected);
   2895              pDVars_str->wADC_JSQR_phB = R3_4_F30X_ADC_InjectedChannelConfig(pDVars_str->ADCx_2, pDParams_str->bIbChannel, 1u, pDParams_str->b_IbSamplingTime, 1u, ADC_ExternalTrigInjecEventEdge_RisingEdge, pDVars_str->ADC_ExternalTriggerInjected);
   2896              
   2897              ((_CPWMC)this)->Methods_str.pPWMC_GetPhaseCurrents = &R3_4_F30X_GetPhaseCurrents;
   2898              ((_CPWMC)this)->Methods_str.pPWMC_TurnOnLowSides = &R3_4_F30X_TurnOnLowSides;
   2899              ((_CPWMC)this)->Methods_str.pPWMC_SwitchOnPWM = &R3_4_F30X_SwitchOnPWM;
   2900              ((_CPWMC)this)->Methods_str.pPWMC_SwitchOffPWM = &R3_4_F30X_SwitchOffPWM;
   2901              
   2902              pVars_str->RLDetectionMode = FALSE;
   2903            }
   2904          }
   2905          
   2906          /**
   2907          * @brief  It is used to set the PWM dutycycle in 6-step mode.
   2908          * @param  this related object of class CPWMC
   2909          * @param  hDuty to be applied in u16
   2910          * @retval It returns the code error 'MC_FOC_DURATION' if any, 'MC_NO_ERROR' 
   2911          *         otherwise. These error codes are defined in MC_type.h
   2912          */
   2913          static uint16_t R3_4_F30X_RLDetectionModeSetDuty(CPWMC this, uint16_t hDuty)
   2914          {
   2915            Vars_t *pVars_Str = &CLASS_VARS;
   2916            pParams_t pParams_str = CLASS_PARAMS;
   2917            pDVars_t pDVars_str = &DCLASS_VARS;
   2918            pDParams_t pDParams_str = DCLASS_PARAMS;
   2919            DVars_t *pLocalVars_Str = &DCLASS_VARS;
   2920            TIM_TypeDef*  TIMx = pDParams_str->TIMx;
   2921            pR3_4_F30XOPAMPParams_t pDOPAMPParams_str = pDParams_str->pOPAMPParams;
   2922            uint16_t hAux;
   2923            
   2924            uint32_t val = ((uint32_t)(PWM_PERIOD) * (uint32_t)(hDuty)) >> 16;
   2925            pVars_Str->hCntPhA = (uint16_t)(val);
   2926            
   2927            /* Set CC4 as PWM mode 2 (default) */
   2928            TIMx->CCMR2 &= CCMR2_CH4_DISABLE;
   2929            TIMx->CCMR2 |= CCMR2_CH4_PWM1;
   2930            
   2931            TIMx->CCR4 = (uint32_t)(PWM_PERIOD) - pParams_str->Ton;
   2932            TIMx->CCR3 = pParams_str->Toff;
   2933            
   2934            if (pDOPAMPParams_str)
   2935            {
   2936              OPAMP_InitTypeDef OPAMP_InitStruct1;
   2937              OPAMP_InitTypeDef OPAMP_InitStruct2;
   2938              OPAMP_InitStruct1.OPAMP_InvertingInput = pDOPAMPParams_str->wOPAMP_InvertingInput;
   2939              OPAMP_InitStruct1.OPAMP_NonInvertingInput = pDOPAMPParams_str->wOPAMP_NonInvertingInput_PHA;
   2940              pLocalVars_Str->wOAMP1CR = R3_4_F30X_OPAMP_Init(pDOPAMPParams_str->wOPAMP_Selection,&OPAMP_InitStruct1);
   2941              OPAMP_InitStruct2.OPAMP_InvertingInput = pDOPAMPParams_str->wOPAMP2_InvertingInput;
   2942              OPAMP_InitStruct2.OPAMP_NonInvertingInput = pDOPAMPParams_str->wOPAMP2_NonInvertingInput_PHB;
   2943              pLocalVars_Str->wOAMP2CR = R3_4_F30X_OPAMP_Init(pDOPAMPParams_str->wOPAMP2_Selection,&OPAMP_InitStruct2);
   2944            }
   2945            else
   2946            {
   2947              pLocalVars_Str->wADC1_JSQR = pLocalVars_Str->wADC_JSQR_phA;
   2948              pLocalVars_Str->wADC2_JSQR = pLocalVars_Str->wADC_JSQR_phB;
   2949            }
   2950            
   2951            TIMx->CCR1 = ((_CPWMC) this)->Vars_str.hCntPhA;
   2952            
   2953            /* Switch Context */
   2954            if (pDOPAMPParams_str)
   2955            {
   2956              uint32_t wAux = OPAMP_BASE + pDOPAMPParams_str->wOPAMP_Selection;
   2957              *(__IO uint32_t *) (wAux) = pDVars_str->wOAMP1CR;
   2958              wAux = OPAMP_BASE + pDOPAMPParams_str->wOPAMP2_Selection;
   2959              *(__IO uint32_t *) (wAux) = pDVars_str->wOAMP2CR;
   2960            }
   2961            pDVars_str->ADCx_1->JSQR = pDVars_str->wADC1_JSQR;
   2962            pDVars_str->ADCx_2->JSQR = pDVars_str->wADC2_JSQR;
   2963              
   2964            /* Limit for update event */
   2965            /* Check the status flag. If an update event has occurred before to set new
   2966            values of regs the FOC rate is too high */
   2967            if (TIMx->SR & TIM_FLAG_Update)
   2968            {
   2969              hAux = MC_FOC_DURATION;
   2970            }
   2971            else
   2972            {
   2973              hAux = MC_NO_ERROR;
   2974            }
   2975            if (((_CPWMC) this)->Vars_str.SWerror == 1u)
   2976            {
   2977              hAux = MC_FOC_DURATION;
   2978              ((_CPWMC) this)->Vars_str.SWerror = 0u;
   2979            }
   2980            return hAux;
   2981          }
   2982          
   2983          #if defined (CCMRAM)
   2984          #if defined (__ICCARM__)
   2985          #pragma location = ".ccmram"
   2986          #elif defined (__CC_ARM)
   2987          __attribute__((section ("ccmram")))
   2988          #endif
   2989          #endif
   2990          /**
   2991          * @brief  It computes and return latest converted motor phase currents motor
   2992          *         during RL detection phase
   2993          * @param  this: related object of class CR3F30X_PWMC
   2994          * @retval Ia and Ib current in Curr_Components format
   2995          */
   2996          static void R3_4_F30X_RLGetPhaseCurrents(CPWMC this,Curr_Components* pStator_Currents)
   2997          {
   2998            pDVars_t pDVars_str = &DCLASS_VARS;
   2999            int32_t wAux;
   3000            int16_t hCurrA = 0, hCurrB = 0;
   3001            
   3002            /* Clear the flag to indicate the start of FOC algorithm*/
   3003            DCLASS_PARAMS->TIMx->SR = (uint16_t)(~TIM_FLAG_Update);
   3004            
   3005            wAux = (int32_t)(pDVars_str->wPhaseBOffset);
   3006            wAux -= (int32_t)(pDVars_str->ADCx_1->JDR1);
   3007            
   3008            /* Check saturation */
   3009            if (wAux > S16_MIN)
   3010            {
   3011              if (wAux < S16_MAX)
   3012              {
   3013              }
   3014              else
   3015              {
   3016                wAux = S16_MAX;
   3017              }
   3018            }
   3019            else
   3020            {
   3021              wAux = S16_MIN;
   3022            }
   3023            
   3024            hCurrA = (int16_t)(wAux);
   3025            
   3026            wAux = (int32_t)(pDVars_str->wPhaseBOffset);
   3027            wAux -= (int32_t)(pDVars_str->ADCx_2->JDR1);
   3028            
   3029            /* Check saturation */
   3030            if (wAux > S16_MIN)
   3031            {
   3032              if (wAux < S16_MAX)
   3033              {
   3034              }
   3035              else
   3036              {
   3037                wAux = S16_MAX;
   3038              }
   3039            }
   3040            else
   3041            {
   3042              wAux = S16_MIN;
   3043            }
   3044            
   3045            hCurrB = (int16_t)(wAux);
   3046            
   3047            pStator_Currents->qI_Component1 = hCurrA;
   3048            pStator_Currents->qI_Component2 = hCurrB;
   3049          }
   3050          
   3051          /**
   3052            * @brief  It turns on low sides switches. This function is intended to be 
   3053            *         used for charging boot capacitors of driving section. It has to be 
   3054            *         called each motor start-up when using high voltage drivers.
   3055            *         This function is specific for RL detection phase.
   3056            * @param  this: related object of class CR3F30X_PWMC
   3057            * @retval none
   3058            */
   3059          static void R3_4_F30X_RLTurnOnLowSides(CPWMC this)
   3060          {  
   3061            pDParams_t pDParams_str = DCLASS_PARAMS;
   3062            TIM_TypeDef* TIMx = DCLASS_PARAMS->TIMx;
   3063            
   3064            /*Turn on the phase A low side switch */
   3065            TIMx->CCR1 = 0u;
   3066          
   3067            /* Clear Update Flag */
   3068            TIM_ClearFlag(TIMx, (uint16_t)(TIM_FLAG_Update));
   3069            
   3070            /* Wait until next update */
   3071            while (TIM_GetFlagStatus(TIMx,TIM_FLAG_Update)==RESET)
   3072            {}
   3073            
   3074            /* Main PWM Output Enable */
   3075            TIMx->BDTR |= TIM_BDTR_MOE;
   3076            
   3077            if ((pDParams_str->LowSideOutputs)== ES_GPIO)
   3078            {
   3079              GPIO_WriteBit(pDParams_str->hCh1NPort, pDParams_str->hCh1NPin, Bit_SET);
   3080              GPIO_WriteBit(pDParams_str->hCh2NPort, pDParams_str->hCh2NPin, Bit_RESET);
   3081              GPIO_WriteBit(pDParams_str->hCh3NPort, pDParams_str->hCh3NPin, Bit_RESET);
   3082            }
   3083            return; 
   3084          }
   3085          
   3086          
   3087          /**
   3088          * @brief  It enables PWM generation on the proper Timer peripheral
   3089          *         This function is specific for RL detection phase.
   3090          * @param  this: related object of class CR3F30X_PWMC
   3091          * @retval none
   3092          */
   3093          static void R3_4_F30X_RLSwitchOnPWM(CPWMC this)
   3094          {
   3095            TIM_TypeDef* TIMx = DCLASS_PARAMS->TIMx;
   3096            pDParams_t pDParams_str = DCLASS_PARAMS;
   3097            pDVars_t pDVars_str = &DCLASS_VARS;
   3098            pR3_4_F30XOPAMPParams_t pDOPAMPParams_str = pDParams_str->pOPAMPParams;
   3099            
   3100            /* wait for a new PWM period */
   3101            TIM_ClearFlag(TIMx, (uint16_t)(TIM_FLAG_Update));
   3102            while (TIM_GetFlagStatus(TIMx,TIM_FLAG_Update) == RESET)
   3103            {}
   3104            /* Clear Update Flag */
   3105            TIM_ClearFlag(TIMx, (uint16_t)(TIM_FLAG_Update));
   3106            
   3107            TIMx->CCR1 = 1u;
   3108            TIMx->CCR4 = (uint32_t)(pDVars_str->Half_PWMPeriod) - 5u;
   3109            pDVars_str->ADCx_2->JSQR = pDVars_str->wADC2_JSQR;
   3110            
   3111            while (TIM_GetFlagStatus(TIMx,TIM_FLAG_Update) == RESET)
   3112            {}
   3113            
   3114            /* Main PWM Output Enable */
   3115            TIMx->BDTR |= TIM_OSSIState_Enable; 
   3116            TIMx->BDTR |= TIM_BDTR_MOE;
   3117            
   3118            if ((pDParams_str->LowSideOutputs)== ES_GPIO)
   3119            {
   3120              if ((TIMx->CCER & TIMxCCER_MASK_CH123) != 0u)
   3121              {
   3122                GPIO_WriteBit(pDParams_str->hCh1NPort, pDParams_str->hCh1NPin, Bit_SET);
   3123                GPIO_WriteBit(pDParams_str->hCh2NPort, pDParams_str->hCh2NPin, Bit_SET);
   3124                GPIO_WriteBit(pDParams_str->hCh3NPort, pDParams_str->hCh3NPin, Bit_RESET);
   3125              }
   3126              else
   3127              {
   3128                /* It is executed during calibration phase the EN signal shall stay off */
   3129                GPIO_WriteBit(pDParams_str->hCh1NPort, pDParams_str->hCh1NPin, Bit_RESET);
   3130                GPIO_WriteBit(pDParams_str->hCh2NPort, pDParams_str->hCh2NPin, Bit_RESET);
   3131                GPIO_WriteBit(pDParams_str->hCh3NPort, pDParams_str->hCh3NPin, Bit_RESET);
   3132              }
   3133            }
   3134            
   3135            pDVars_str->wADC1_JSQR = pDVars_str->wADC_JSQR_phA;
   3136            pDVars_str->wADC2_JSQR = pDVars_str->wADC_JSQR_phB;
   3137            
   3138            /* Switch Context */
   3139            if (pDOPAMPParams_str)
   3140            {
   3141              uint32_t wAux = OPAMP_BASE + pDOPAMPParams_str->wOPAMP_Selection;
   3142              *(__IO uint32_t *) (wAux) = pDVars_str->wOAMP1CR;
   3143              wAux = OPAMP_BASE + pDOPAMPParams_str->wOPAMP2_Selection;
   3144              *(__IO uint32_t *) (wAux) = pDVars_str->wOAMP2CR;
   3145            }
   3146            pDVars_str->ADCx_1->JSQR = pDVars_str->wADC1_JSQR;
   3147            pDVars_str->ADCx_2->JSQR = pDVars_str->wADC2_JSQR;
   3148            return; 
   3149          }
   3150          
   3151          
   3152          /**
   3153          * @brief  It disables PWM generation on the proper Timer peripheral acting on 
   3154          *         MOE bit
   3155          *         This function is specific for RL detection phase.
   3156          * @param  this: related object of class CR3F30X_PWMC
   3157          * @retval none
   3158          */
   3159          static void R3_4_F30X_RLSwitchOffPWM(CPWMC this)
   3160          {
   3161            pDParams_t pDParams_str = DCLASS_PARAMS;
   3162            pDVars_t pDVars_str = &DCLASS_VARS;
   3163            TIM_TypeDef* TIMx = pDParams_str->TIMx;
   3164            
   3165            /* Main PWM Output Disable */
   3166            if (DCLASS_VARS.BrakeActionLock == TRUE)
   3167            {
   3168            }
   3169            else
   3170            {
   3171              TIMx->BDTR &= ~((uint32_t)(TIM_OSSIState_Enable));
   3172              
   3173              if ((pDParams_str->LowSideOutputs)== ES_GPIO)
   3174              {
   3175                GPIO_WriteBit(pDParams_str->hCh1NPort, pDParams_str->hCh1NPin, Bit_RESET);
   3176                GPIO_WriteBit(pDParams_str->hCh2NPort, pDParams_str->hCh2NPin, Bit_RESET);
   3177                GPIO_WriteBit(pDParams_str->hCh3NPort, pDParams_str->hCh3NPin, Bit_RESET);
   3178              }
   3179            }
   3180            TIMx->BDTR &= (uint32_t)~TIM_BDTR_MOE;
   3181            
   3182            /* ADC_ITConfig(ADCx, ADC_IT_JEOS, DISABLE);*/
   3183            pDVars_str->ADCx_1->IER &= (~(uint32_t)ADC_IT_JEOS);
   3184            
   3185            /* Flushing JSQR queue of context by setting JADSTP = 1 (JQM)=1 */
   3186            pDVars_str->ADCx_1->CR |= ADC_CR_JADSTP;
   3187            pDVars_str->ADCx_2->CR |= ADC_CR_JADSTP;
   3188            
   3189            pDVars_str->ADCx_1->JSQR = R3_4_F30X_ADC_InjectedChannelConfig(pDVars_str->ADCx_1, 0u, 1u, 0u, 1u, ADC_ExternalTrigInjecEventEdge_RisingEdge, pDVars_str->ADC_ExternalTriggerInjected);
   3190            pDVars_str->ADCx_2->JSQR = R3_4_F30X_ADC_InjectedChannelConfig(pDVars_str->ADCx_2, 0u, 1u, 0u, 1u, ADC_ExternalTrigInjecEventEdge_RisingEdge, pDVars_str->ADC_ExternalTriggerInjected);
   3191            pDVars_str->ADCx_1->CR |= ADC_CR_JADSTART;
   3192            pDVars_str->ADCx_2->CR |= ADC_CR_JADSTART;
   3193            
   3194            TIM_OC4PreloadConfig(TIMx, TIM_OCPreload_Disable);
   3195            /* Set CC4 as PWM mode 2 (default) */
   3196            TIMx->CCMR2 &= CCMR2_CH4_DISABLE;
   3197            TIMx->CCMR2 |= CCMR2_CH4_PWM2;
   3198            TIMx->CCR4 = 0xFFFFu;
   3199            TIMx->CCR4 = 0x0u;
   3200            TIM_OC4PreloadConfig(TIMx, TIM_OCPreload_Enable);
   3201            
   3202            while (ADC_GetFlagStatus(pDVars_str->ADCx_1,ADC_FLAG_JEOS)==RESET)
   3203            {}
   3204            while (ADC_GetFlagStatus(pDVars_str->ADCx_2,ADC_FLAG_JEOS)==RESET)
   3205            {}
   3206            
   3207            /* ADCx_1 Injected conversions end interrupt enabling */
   3208            ADC_ClearFlag(pDVars_str->ADCx_1, ADC_FLAG_JEOS);
   3209            ADC_ClearFlag(pDVars_str->ADCx_2, ADC_FLAG_JEOS);
   3210            ADC_ITConfig(pDVars_str->ADCx_1, ADC_IT_JEOS, ENABLE);  
   3211            return;
   3212          }
   3213          
   3214          /**
   3215          * @}
   3216          */
   3217          
   3218          /**
   3219          * @}
   3220          */
   3221          
   3222          /**
   3223          * @}
   3224          */
   3225          
   3226          /******************* (C) COPYRIGHT 2016 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   R3_4_F30X_ADC_InjectedChannelConfig
      12   R3_4_F30X_ADC_SetSamplingTime
      40   R3_4_F30X_CurrentReadingCalibration
        40   -> R3_4_F30X_SwitchOffPWM
        40   -> R3_4_F30X_SwitchOnPWM
       0   R3_4_F30X_ExecRegularConv
       4   R3_4_F30X_GetPhaseCurrents
       0   R3_4_F30X_HFCurrentsCalibrationAB
       0   R3_4_F30X_HFCurrentsCalibrationC
      16   R3_4_F30X_IRQHandler
        16   -> GPIO_WriteBit
     168   R3_4_F30X_Init
       168   -> ADC_ClearFlag
       168   -> ADC_Cmd
       168   -> ADC_CommonInit
       168   -> ADC_CommonStructInit
       168   -> ADC_DeInit
       168   -> ADC_GetCalibrationStatus
       168   -> ADC_GetFlagStatus
       168   -> ADC_ITConfig
       168   -> ADC_Init
       168   -> ADC_SelectCalibrationMode
       168   -> ADC_SelectQueueOfContextMode
       168   -> ADC_StartCalibration
       168   -> ADC_StructInit
       168   -> ADC_VoltageRegulatorCmd
       168   -> COMP_Cmd
       168   -> COMP_Init
       168   -> COMP_LockConfig
       168   -> DAC_Cmd
       168   -> DAC_Init
       168   -> DAC_SetChannel1Data
       168   -> DAC_SetChannel2Data
       168   -> DAC_SoftwareTriggerCmd
       168   -> DBGMCU_APB2PeriphConfig
       168   -> GPIO_Init
       168   -> GPIO_PinAFConfig
       168   -> GPIO_PinLockConfig
       168   -> GPIO_StructInit
       168   -> NVIC_Init
       168   -> OPAMP_Cmd
       168   -> OPAMP_Init
       168   -> OPAMP_PGAConfig
       168   -> R3_4_F30X_TIMxInit
       168   -> RCC_AHBPeriphClockCmd
       168   -> RCC_APB1PeriphClockCmd
       168   -> RCC_APB2PeriphClockCmd
       168   -> RCC_ClockSecuritySystemCmd
       168   -> RCC_TIMCLKConfig
       168   -> TIM_OC4PreloadConfig
       0   R3_4_F30X_IsOverCurrentOccurred
       0   R3_4_F30X_OPAMP_Init
      32   R3_4_F30X_RLDetectionModeDisable
        32   -> TIM_CCxCmd
        32   -> TIM_CCxNCmd
        32   -> TIM_SelectOCxM
        32   -> TIM_SetCompare1
        32   -> TIM_SetCompare2
        32   -> TIM_SetCompare3
      24   R3_4_F30X_RLDetectionModeEnable
        24   -> TIM_CCxCmd
        24   -> TIM_CCxNCmd
        24   -> TIM_SelectOCxM
        24   -> TIM_SetCompare1
      16   R3_4_F30X_RLDetectionModeSetDuty
       8   R3_4_F30X_RLGetPhaseCurrents
       0   R3_4_F30X_RLSwitchOffPWM
        16   -> ADC_ClearFlag
        16   -> ADC_GetFlagStatus
         0   -> ADC_ITConfig
        16   -> GPIO_WriteBit
        16   -> TIM_OC4PreloadConfig
      24   R3_4_F30X_RLSwitchOnPWM
        24   -> GPIO_WriteBit
        24   -> TIM_ClearFlag
        24   -> TIM_GetFlagStatus
      16   R3_4_F30X_RLTurnOnLowSides
         0   -> GPIO_WriteBit
        16   -> GPIO_WriteBit
        16   -> TIM_ClearFlag
        16   -> TIM_GetFlagStatus
       8   R3_4_F30X_SetADCSampPointCalibration
         0   -> R3_4_F30X_WriteTIMRegisters
      32   R3_4_F30X_SetADCSampPointSect1
         0   -> R3_4_F30X_WriteTIMRegisters
      32   R3_4_F30X_SetADCSampPointSect2
         0   -> R3_4_F30X_WriteTIMRegisters
      32   R3_4_F30X_SetADCSampPointSect3
         0   -> R3_4_F30X_WriteTIMRegisters
      32   R3_4_F30X_SetADCSampPointSect4
         0   -> R3_4_F30X_WriteTIMRegisters
      32   R3_4_F30X_SetADCSampPointSect5
         0   -> R3_4_F30X_WriteTIMRegisters
      32   R3_4_F30X_SetADCSampPointSect6
         0   -> R3_4_F30X_WriteTIMRegisters
      16   R3_4_F30X_SwitchOffPWM
        16   -> ADC_ClearFlag
        16   -> ADC_GetFlagStatus
         0   -> ADC_ITConfig
        16   -> GPIO_WriteBit
        16   -> TIM_OC4PreloadConfig
      24   R3_4_F30X_SwitchOnPWM
        24   -> GPIO_WriteBit
        24   -> TIM_ClearFlag
        24   -> TIM_GetFlagStatus
      80   R3_4_F30X_TIMxInit
        80   -> TIM_ClearITPendingBit
        80   -> TIM_DeInit
        80   -> TIM_GenerateEvent
        80   -> TIM_ITConfig
        80   -> TIM_OC1Init
        80   -> TIM_OC1PreloadConfig
        80   -> TIM_OC2Init
        80   -> TIM_OC2PreloadConfig
        80   -> TIM_OC3Init
        80   -> TIM_OC3PreloadConfig
        80   -> TIM_OC4Init
        80   -> TIM_OC4PreloadConfig
        80   -> TIM_OCStructInit
        80   -> TIM_SelectInputTrigger
        80   -> TIM_SelectOutputTrigger
        80   -> TIM_SelectOutputTrigger2
        80   -> TIM_SelectSlaveMode
        80   -> TIM_SetCounter
        80   -> TIM_TimeBaseInit
        80   -> TIM_TimeBaseStructInit
      16   R3_4_F30X_TurnOnLowSides
         0   -> GPIO_WriteBit
        16   -> GPIO_WriteBit
        16   -> TIM_ClearFlag
        16   -> TIM_GetFlagStatus
      24   R3_4_F30X_WriteTIMRegisters
        24   -> TIM_OC4PreloadConfig
      16   R3_4_F3XX_NewObject
        16   -> PWMC_NewObject
        16   -> Set_IRQ_Handler
      16   R3_4_F3XX_StartTimers
        16   -> RCC_APB1PeriphClockCmd
        16   -> TIM_Cmd
        16   -> TIM_DeInit
        16   -> TIM_SelectOutputTrigger
        16   -> TIM_TimeBaseInit
        16   -> TIM_TimeBaseStructInit


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable0
       4  ??DataTable0_1
       4  ??DataTable0_2
       4  ??DataTable0_3
       4  ??DataTable0_4
       4  ??DataTable0_5
       4  ??DataTable0_6
       4  ??DataTable0_7
       4  ??DataTable1
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_2
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable14_2
       4  ??DataTable14_3
       4  ??DataTable14_4
       4  ??DataTable14_5
       4  ??DataTable14_6
       4  ??DataTable1_1
       4  ??DataTable1_10
       4  ??DataTable1_11
       4  ??DataTable1_12
       4  ??DataTable1_2
       4  ??DataTable1_3
       4  ??DataTable1_4
       4  ??DataTable1_5
       4  ??DataTable1_6
       4  ??DataTable1_7
       4  ??DataTable1_8
       4  ??DataTable1_9
       4  ??DataTable3
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_2
       4  ??DataTable6_3
       6  ?Subroutine0
     256  ?Subroutine1
       6  ?Subroutine2
       6  ?Subroutine3
     118  R3_4_F30X_ADC_InjectedChannelConfig
      82  R3_4_F30X_ADC_SetSamplingTime
     438  R3_4_F30X_CurrentReadingCalibration
      32  R3_4_F30X_ExecRegularConv
     228  R3_4_F30X_GetPhaseCurrents
      54  R3_4_F30X_HFCurrentsCalibrationAB
      42  R3_4_F30X_HFCurrentsCalibrationC
     104  R3_4_F30X_IRQHandler
    3536  R3_4_F30X_Init
      34  R3_4_F30X_IsOverCurrentOccurred
      24  R3_4_F30X_OPAMP_Init
      72  R3_4_F30X_PWMC_Allocated
          R3_4_F30X_PWMCpool
     404  R3_4_F30X_RLDetectionModeDisable
     386  R3_4_F30X_RLDetectionModeEnable
     170  R3_4_F30X_RLDetectionModeSetDuty
      78  R3_4_F30X_RLGetPhaseCurrents
       4  R3_4_F30X_RLSwitchOffPWM
     182  R3_4_F30X_RLSwitchOnPWM
      84  R3_4_F30X_RLTurnOnLowSides
      36  R3_4_F30X_SetADCSampPointCalibration
     280  R3_4_F30X_SetADCSampPointSect1
     288  R3_4_F30X_SetADCSampPointSect2
     288  R3_4_F30X_SetADCSampPointSect3
     288  R3_4_F30X_SetADCSampPointSect4
     284  R3_4_F30X_SetADCSampPointSect5
     280  R3_4_F30X_SetADCSampPointSect6
       6  R3_4_F30X_SwitchOffPWM
     220  R3_4_F30X_SwitchOnPWM
     564  R3_4_F30X_TIMxInit
      88  R3_4_F30X_TurnOnLowSides
     116  R3_4_F30X_WriteTIMRegisters
     142  R3_4_F3XX_NewObject
      90  R3_4_F3XX_StartTimers

 
    72 bytes in section .bss
 9 388 bytes in section .text
 
 9 388 bytes of CODE memory
    72 bytes of DATA memory

Errors: none
Warnings: none
